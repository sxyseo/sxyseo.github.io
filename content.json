[{"title":"Kafka运行环境的搭建","date":"2018-02-08T08:52:05.000Z","path":"20180208/Kafka运行环境的搭建.html","text":"准备学习下Kafka神器，Kafka是用Scala语言开发的，首先需要安装JDK环境。Java环境还是比较容易配置的，目前系统是Win10. 先到官网下载JDK，这里下载的是JDK 1.8，下载后双击运行安装，选择路径。 桌面此电脑右键选择属性，打开高级系统设置，点击环境变量，在系统变量中新增变量名JAVA_HOME，变量值为 JDK 1.8 安装路径，也就是刚刚安装的路径。由于默认安装在 Program Files目录下，目录名之间有空格，有可能在运行某些应用时因JDK安装路径有空格而报错，这个有点坑。再新增变量名 CLASSPATH，变量值为1.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 最后的结果如下：123系统变量 JAVA_HOME C:\\Program Files\\Java\\jdk1.8.0_131用户变量 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar新增PATH变量 PATH %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 设置好了后，重新打开一个终端，运行1java -version 显示类似下面结果，说明JDK环境搭建成功。123java version \"1.8.0_131\"Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 类似的有maven环境，tomcat环境，Java开发必备，当然也可以Docker。 还有Git环境。 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1ssh-keygen -t rsa -C \"youremail@example.com\" 你需要把邮件地址youremail@example.com换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。","tags":[]},{"title":"如何安装 Ruby","date":"2018-02-04T13:59:29.000Z","path":"20180204/如何安装-Ruby.html","text":"安装 Ruby可以使用多种工具安装 Ruby。本页介绍如何使用主流的包管理系统和第三方工具管理和安装 Ruby，以及如何通过源码编译安装。 选择安装方式安装 Ruby 的方式有多种： 如果使用的是类 UNIX 操作系统，使用系统的包管理器是最简单的安装方式。但是，包管理器中的 Ruby 版本通常都不是最新的。安装工具能够安装指定的一个或多个 Ruby 版本。有针对 Windows 的安装包。管理工具能帮助你在系统中安装的多个 Ruby 版本之间切换。最后，也可以通过源码编译安装 Ruby。下面概述针对不同需求和不同平台的安装方式。 包管理系统Debian, UbuntuCentOS, Fedora, RHELGentooArch LinuxOS XSolaris, OpenIndiana其他发行版安装工具ruby-buildruby-installRubyInstaller (Windows)RailsInstaller 和 Ruby Stack管理工具chrubyrbenvRVMuru通过源码编译安装包管理系统如果不能自己编译 Ruby，也不想使用第三方工具，可以使用系统中的包管理器安装 Ruby。 许多 Ruby 社区的成员强烈建议，应该使用第三方工具来安装 Ruby，不要用系统的包管理器。详细的优缺点超出了本页的讨论范畴，基本原因是大多数系统包管理器里的 Ruby 版本比较老。如果想使用最新的 Ruby 版本，要确保包的名称正确，或者使用后面列出的工具。 apt（Debian 或 Ubuntu）Debian GNU/Linux 和 Ubuntu 使用 apt 包管理器。用法如下：1$ sudo apt-get install ruby-full 撰写本文时，在 Debian 和 Ubuntu 下，ruby-full 包提供的是老旧的 Ruby 2.3.1。 yum（CentOS、Fedora 或 RHEL）CentOS、Fedora 和 RHEL 使用 yum 包管理器。用法如下： 1$ sudo yum install ruby 安装的 Ruby 版本通常是发行版发行日能打包的最新版。 portage（Gentoo）Gentoo 使用 portage 包管理器。1$ sudo emerge dev-lang/ruby 一般来说，这将安装 1.9 和 2.0 版本，不过还有更多版本可供安装。如果想安装指定的版本，要在 make.conf 文件中设置 RUBY_TARGETS。详见 Gentoo Ruby Project 网站。 pacman（Arch Linux）Arch Linux 使用 pacman 包管理器。要安装 Ruby，只需要执行下述命令：1$ sudo pacman -S ruby 这将安装最新的 Ruby 稳定版。 Homebrew（OS X）OS X El Capitan、Yosemite 和 Mavericks 内置了 Ruby 2.0。OS X Mountain Lion、Lion 和 Snow Leopard 内置了 Ruby 1.8.7。 许多 OS X 用户使用 Homebrew 作为包管理器。用 Homebrew 能够非常简单地获取到最新版的 Ruby：1$ brew install ruby 这将安装最新版的 Ruby。 Solaris 和 OpenIndianaSunfreeware 上的 Solaris 8 到 10 内置了 Ruby 1.8.7，Blastwave 同样如此。Ruby 1.9.2p0 在 Sunfreeware 上也有，但是这一版已经过时。 若想在 OpenIndiana 上安装 Ruby，要使用 Image Packaging System (IPS) 客户端。这将直接从 OpenSolaris 代码库安装 Ruby 1.9 和 RubyGems：1$ pkg install runtime/ruby-18 然而，第三方工具或许是获取最新版 Ruby 更好的方法。 其它发行版在其它操作系统中，可以使用包管理器在包仓库中搜索 Ruby，或许使用第三方工具是更好的选择。 安装工具如果系统或者包管理器提供的 Ruby 版本已经过时，可以使用第三方安装工具来安装更新的版本。其中许多工具允许在同一个系统中安装多个 Ruby 版本，相关的工具能帮你在不同的版本之间切换。如果打算用 RVM 作为版本管理工具，不需要其它的安装工具，它自己就具有这些功能。 ruby-buildruby-build 是 rbenv 的一个插件，能在任意目录中编译和安装不同版本的 Ruby。ruby-build 也可以不依赖 rbenv 而单独使用。支持的平台有 OS X、Linux 和其它类 UNIX 操作系统。 ruby-installruby-install 能在任意目录中编译和安装不同版本的 Ruby。还有个兄弟工具，chruby，可以用来切换不同的 Ruby 版本。支持的平台有 OS X、Linux 和其它类 UNIX 操作系统。 RubyInstaller如果使用 Windows，有个不错的项目能帮你安装 Ruby：RubyInstaller。它能帮你在 Windows 中安装所需的所有 Ruby 开发环境。 下载、运行，即可! RailsInstaller 和 Ruby Stack如果是为了使用 Ruby on Rails 而安装 Ruby，可以使用下列安装工具： RailsInstaller，使用的是 RubyInstaller，但包括了其它能够帮助 Rails 开发的工具。支持 OS X 和 Windows。Bitnami Ruby Stack，提供了完整的 Rails 开发环境。支持 OS X、Linux、Windows、虚拟机和云镜像。管理工具许多 Ruby 程序员使用 Ruby 管理工具管理不同版本的 Ruby。这些管理工具有很多额外的优点，但没有官方支持。不过，这些工具背后的社群都乐于助人。 chrubychruby 用于在不同的 Ruby 版本之间切换。chruby 能够管理用 ruby-install 或者通过源码编译安装的 Ruby。 rbenvrbenv 用于管理系统中安装的多个 Ruby 版本。它不能直接安装 Ruby，但有个流行的插件叫 ruby-build 能够安装 Ruby。这两个工具都支持 OS X、Linux 和其它类 UNIX 操作系统。 RVM（“Ruby Version Manager”）RVM 能在系统中安装和管理多个 Ruby 版本。同时还能管理不同的 gem 集。支持 OS X、Linux 和其它类 UNIX 操作系统。 uruUru 是一个轻量级的命令行工具，支持多平台，能够帮你在 OS X、Linux 和 Windows 上使用不同的 Ruby 版本。 通过源码编译安装当然，也可以通过源码安装 Ruby。下载，解压，然后执行：123$ ./configure$ make$ sudo make install 默认情况下，Ruby 安装到 /usr/local 目录。如果想使用其他目录，可以把 –prefix=DIR 选项传给 ./configure 脚本。 因为无法使用任何工具来管理通过源码编译安装的 Ruby，所以使用第三方工具或者包管理器或许是更好的选择。 这边ubuntu环境选择的是1sudo apt-get install ruby-full 安装的，简单方便。 详情请查看 http://www.ruby-lang.org/zh_cn/documentation/installation/","tags":[{"name":"ruby","slug":"ruby","permalink":"https://jiangshaobo.cn/tags/ruby/"}]},{"title":"Hexo渲染时排除目录文件夹或部分文件","date":"2018-01-31T05:28:03.000Z","path":"20180131/Hexo渲染时排除目录文件夹或部分文件.html","text":"使用Hexo的时候，有时候需要写点Demo实验，发现Hexo也渲染了，那么怎么才可以让Hexo跳过目录或者部分文件，在查看_config.yml的时候发现 12345678910111213141516171819# Directory# 资源文件夹，这个文件夹用来存放内容source_dir: source# 公共文件夹，这个文件夹用于存放生成的站点文件public_dir: public# 标签文件夹tag_dir: tags# 归档文件夹archive_dir: archives# 分类文件夹category_dir: categories# Include code 文件夹code_dir: downloads/code# 资源文件夹assets_dir: assets# 国际化（i18n）文件夹i18n_dir: :lang# 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径# skip_render: *.html 注意skip_render，跳过指定文件的渲染，您可使用 glob 表达式来匹配路径，把注释去掉，让此配置起效。 在提交网址的时候，搜索引擎确认网站所有权时(站长统计验证)需要下载一个验证文件来进行验证，要是这个文件被渲染了，验证就可能会失败了。或者，有时候会写一些简单的html示例页面，这也是不希望Hexo渲染的。因此有必要针对某个文件或者目录进行排除。Hexo的配置文件中提供了配置项skip_render。 注意只有source目录下的文件才会发布到public（能够在网络上访问到），因此Hexo只渲染source目录下的文件。skip_render参数设置的路径是相对于source目录的路径。 设置排除项假设source目录下的文件如以下目录树所示,Ubuntu下 tree 命令以树形结构显示文件夹目录结构，先安装tree1sudo apt-get install tree 只查看当前第一级的目录和文件1tree -L 1 123456789.├── assets├── CNAME├── demo├── instagram├── labs├── photos├── _posts└── t 只查看当前第二级的目录和文件 1tree -L 2 结果如下：12345678910111213141516171819202122232425262728293031.├── assets│ ├── demo│ └── img├── CNAME├── demo│ ├── baidu.html│ ├── google.html│ └── index.html├── instagram│ └── index.md├── labs│ ├── index│ └── index.md├── photos│ ├── index.ejs│ ├── ins.css│ ├── ins.js│ ├── ins.json│ ├── lazyload.min.js│ └── tools.js├── _posts│ ├── centos-ubuntu下安装nodejs环境.md│ ├── CNAME│ └── hello-world.md└── t ├── index.ejs ├── ins.css ├── ins.js ├── ins.json └── lazyload.min.js 排除单个文件排除demo/index.html1skip_render: 'demo/index.html' 排除多个文件排除baidu.html和google.html123skip_render: - 'demo/baidu.html' - 'demo/google.html' 或者 1skip_render: '*.html' 后者会排除source目录下所有后缀为html的文件，但是不会排除子目录如demo及其子目录中的html文件。 排除demo目录下baidu.html和google.html以及index.html1234skip_render: - 'demo/baidu.html' - 'demo/google.html' - 'demo/index.html' 或者1skip_render: 'demo/*.html' demo目录下新增other目录，另外新增几个文件1234mkdir demo/othertouch demo/other/test.htmltouch demo/other/test1.htmltouch demo/other/test2.md 排除source/demo/other目录中的所有html文件 1skip_render: 'demo/other/*.html' 这不会排除test2.md文件 排除source/demo/other目录中的所有文件 1skip_render: 'demo/other/**' 排除baidu.html和google.html以及整个source/demo目录 123skip_render: - 'demo/*.html' - 'demo/other/**' 可以到public文件下查看排除所有特定后缀的文件，使用 glob 表达式来匹配路径，那么什么是glob表达式呢？","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiangshaobo.cn/tags/hexo/"},{"name":"skip_render","slug":"skip-render","permalink":"https://jiangshaobo.cn/tags/skip-render/"}]},{"title":"OpenLayers 3 注意事项","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch14/index.html","text":"注意事项 EasyUI和OL3有冲突，体现在浏览器大小缩放时，地图会变形，具体原因未知。 ol.js这个文件千万不能使用源码目录中的src\\ol\\ol.js。请下载官网的*-dist.zip，用解压后文件夹里面的ol.js。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 进阶实例","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch12/index.html","text":"进阶实例前面的基础知识，用于应对基本应用没有问题，但如果想更进一步的结合在一起应用，或者解决更为复杂一点的问题，则稍显困难。本章节针对这类问题给出一些实例讲解，以解决广大ol3使用者的困惑，用于感谢大家对本教程的支持。针对这类问题，曾经在Openlayer3 QQ群里面收集统计过，下面的例子就是基于这些统计数据分析讨论而出的。如果你有什么其他的想法或意见，请在下方留言或QQ联系我（11364382），谢谢。 通过wfs增删改查要素本节将讲解ol3使用wfs同后台geoserver进行交互，从而实现要素的增删改查。由于geoserver需要服务器端，所以我们将从环境搭建开始讲解，使用公开的数据源，进行查询，修改，添加，删除操作的演示，使得大家最终学会。 在windows环境下配置GeoServer由于wfs协议涉及到跨域的问题，在配置过程中，我们也将把跨域的环境配置好。虽然跨域的解决方式有很多，但此处选择一个稍微简单的方式，详见下面的具体步骤。 安装Java环境我们使用tomcat作为服务器，所以需要java环境，如果你不确定是否安装有java环境，则可以在命令终端执行： java -version，比如我的环境： 如果提示java命令找不到的错误，说明你得优先安装java环境，请到官网下载最新的Java进行安装。 下载Tomcat安装好java环境后，我们就到Tomcat官网下载Tomcat，如果java环境是64位的，记得下载64位的Tomcat，如果是32位的java环境，就需要下载32位的tomcat。如上图所示，我的是64位java环境，我选择下载8.5.4版本，64位的windows环境的tomcat： apache-tomcat-8.5.4-windows-x64.zip。 下载后，解压到一个指定的目录， 我放在了F:\\apache-tomcat-8.5.4。记住，解压就可以了，免安装，此时需要验证一下是否能正常启动Tomcat，启动命令终端，执行tomcat目录下的bin\\startup.bat，如下： 从上图可以发现，我们还没有配置环境变量JAVA_HOME或者JRE_HOME。那么我先配置一个JAVA_HOME的环境变量，配置好后，记得注销或者重启电脑，让环境变量生效。 然后重新执行命令，正确启动如下： 成功启动会弹出一个新的tomcat命令行窗口，参见上图左边的命令行窗口。 安装GeoServer此时，我们需要到GeoServer官网去下载geoserver，我选择了最新的2.9.1版本，由于我使用tomcat作为服务器，所以我选择下载Web Archive格式的geoserver-2.9.1-war.zip。 下载后解压到得到war文件：geoserver.war，把该文件放置到tomcat目录下的webapps目录下，比如放置该文件后，我的路径为：F:\\apache-tomcat-8.5.4\\webapps\\geoserver.war。 然后在命令行终端启动tomcat，可能需要稍微等待一下，因为要部署geoserver，待tomcat命令行终端启动完成，就可以打开浏览器输入http://localhost:8080/geoserver打开geoserver的管理页面，如下： 见到这个页面，也就安装成功了。如果没有出现该页面，请按照前面的步骤检查一下什么地方出问题了。 跨域配置由于tomcat从7.0.41版本开始就支持跨域了，参见CORS on Tomcat，我们下载的tomcat是8.5.4，自然就能很好的支持了，只需要进行下面的简单配置： 找到geoserver的web.xml文件，我的电脑对应的路径为F:\\apache-tomcat-8.5.4\\webapps\\geoserver\\WEB-INF\\web.xml 打开该文件，把下面的配置添加在该文件中：12345678 &lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后再重新启动tomcat即可。 配置数据源为了后续进行wfs的各项使用演示，我就使用geoserver官方中使用的数据nyc_roads.zip。这份数据的配置，官网也提供了指导，参见Publishing a shapefile。 下面就以我的计算机配置为例，进行说明： 下载后解压，把压缩包里面的nyc_roads.dbf, nyc_roads.prj, nyc_roads.shp, nyc_roads.shx放在目录F:\\apache-tomcat-8.5.4\\webapps\\geoserver\\data\\data\\nyc_roads下，nyc_roads这个目录没有，就新建一个。 启动tomcat，在浏览器中打开geoserver的配置页面http://localhost:8080/geoserver，使用用户admin登录，密码为geoserver。 创建工作区： 创建数据存储： 创建图层，数据源配置好后，保存，就出现下面这个界面： 点击发布创建新图层： 最后点击页面最下方的保存按钮，就配置好了。 最后预览一下，点击左边的Layer Preview，在右边找到刚才创建的图层nyc_roads:nyc_roads，点击右边的OpenLayers，就可以打开新页面，显示预览结果。 出现最后一个页面，就说明数据源配置好了。 通过wfs查询要素一切都准备好了，现在终于可以通过ol3加载配置好的数据了。上一节中最后的预览结果，大家已经看到了，此处我们自己通过ol3来实现这个预览页面，效果图如下： 对应的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html&gt;&lt;head&gt; &lt;title&gt;wfs demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../ol3.15.1/ol.css\" type=\"text/css\" /&gt; &lt;script src=\"../ol3.17.1/ol-debug.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"map\" style=\"width:100%;height:100%;\"&gt;&lt;/div&gt; &lt;script&gt; var vector = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; format: new ol.format.GeoJSON(), url: 'http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326' &#125;), style: function(feature, resolution) &#123; return new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'blue', width: 1 &#125;) &#125;); &#125; &#125;); var map = new ol.Map(&#123; layers: [new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), vector], target: 'map', view: new ol.View(&#123; center: [-73.99710639567148, 40.742270050255556], maxZoom: 19, zoom: 14, projection: 'EPSG:4326' &#125;) &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 和一般的矢量地图加载没什么两样，对于wfs而言，需要弄明白的是ol.source.Vector的url参数： http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326。 如果对wfs协议不太清楚的，建议优先看一下geoserver的官网文档WFS。 此处我们要获取所有的要素，所以设置request=GetFeature，typeNames的值设置为nyc_roads:nyc_roads，是因为我们之前配置的图层命名如此，可以在geoserver管理页面的Layer Preview里面看对应图层的Name。 对于outputFormat和srsname就不做过多解释，大家看值就容易明白了。因为view设置的projection: &#39;EPSG:4326&#39;，所以此处设置srsname=EPSG:4326。 BTW: 上面是全部查询，我们知道wfs也支持filter，所以我们可以在url里面设置filter，从而实现更细粒度的查询，比如这样：http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326&amp;cql_filter=in (&#39;nyc_roads.1162&#39;)。 大家可以自行用这个url进行测试一下。关于filter更详细的信息参见Supported filter languages。 因为这不是教程的重点，所以此处不进行细说。 通过wfs修改要素在查询的基础上，本小节我们更进一步对界面上呈现的要素进行修改，然后通过wfs协议保存到服务器端。界面效果如下: 在界面上方，先点击查询按钮，通过wfs协议把所有的要素查询到前端界面上显示，然后选择复选框编辑，就可以选择界面上的线段，进行编辑，比如把直线编辑成W形状，然后点击按钮保存，就可以把编辑后的线段保存下来。 在点击保存按钮之前，请打开开发者面板，然后再点击保存，之后就可以看到发起了一个wfs的http请求到geoserver服务器，请求的url为：http://localhost:8080/geoserver/wfs?service=wfs，发送的内容大致为:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;Transaction xmlns=\"http://www.opengis.net/wfs\" service=\"WFS\" version=\"1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\"&gt; &lt;Update typeName=\"feature:nyc_roads\" xmlns:feature=\"http://geoserver.org/nyc_roads\"&gt; &lt;Property&gt; &lt;Name&gt;the_geom&lt;/Name&gt; &lt;Value&gt; &lt;MultiLineString xmlns=\"http://www.opengis.net/gml\" srsName=\"EPSG:4326\"&gt; &lt;lineStringMember&gt; &lt;LineString srsName=\"EPSG:4326\"&gt; &lt;posList&gt;-73.98528635501862 40.768332481384284 -73.98608637 40.76719342 -73.98449242115021 40.767849683761604 -73.98447096347809 40.76647639274598 -73.98299038410187 40.767334699630744 -73.98336657 40.76604531&lt;/posList&gt; &lt;/LineString&gt; &lt;/lineStringMember&gt; &lt;/MultiLineString&gt; &lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;modified&lt;/Name&gt; &lt;Value&gt;5/28/2001&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;name&lt;/Name&gt; &lt;Value&gt;W 56 ST&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;vsam&lt;/Name&gt; &lt;Value&gt;15060&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;sourcedate&lt;/Name&gt; &lt;Value&gt;3/31/1996&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;sourcetype&lt;/Name&gt; &lt;Value&gt;Photogrammetric&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;source_id&lt;/Name&gt; &lt;Value&gt;96083&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;borough&lt;/Name&gt; &lt;Value&gt;Manhattan&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;feat_code&lt;/Name&gt; &lt;Value&gt;2900&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;feat_desc&lt;/Name&gt; &lt;Value&gt;Paved Road&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;exported&lt;/Name&gt; &lt;Value&gt;05/19/2004&lt;/Value&gt; &lt;/Property&gt; &lt;Property&gt; &lt;Name&gt;feat_type&lt;/Name&gt; &lt;Value&gt;0&lt;/Value&gt; &lt;/Property&gt; &lt;Filter xmlns=\"http://www.opengis.net/ogc\"&gt; &lt;FeatureId fid=\"nyc_roads.882\" /&gt; &lt;/Filter&gt; &lt;/Update&gt;&lt;/Transaction&gt; 如果保存成功，则response的内容大致如下：1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;wfs:TransactionResponse xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sf=\"http://www.openplans.org/spearfish\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:nyc_roads=\"http://geoserver.org/nyc_roads\" xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:ows=\"http://www.opengis.net/ows\" xmlns:tiger=\"http://www.census.gov\" xmlns:topp=\"http://www.openplans.org/topp\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x mlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.1.0\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://localhost:8080/geoserver/schemas/wfs/1.1.0/wfs.xsd\"&gt; &lt;wfs:TransactionSummary&gt; &lt;wfs:totalInserted&gt;0&lt;/wfs:totalInserted&gt; &lt;wfs:totalUpdated&gt;1&lt;/wfs:totalUpdated&gt; &lt;wfs:totalDeleted&gt;0&lt;/wfs:totalDeleted&gt; &lt;/wfs:TransactionSummary&gt; &lt;wfs:TransactionResults/&gt; &lt;wfs:InsertResults&gt; &lt;wfs:Feature&gt;&lt;ogc:FeatureId fid=\"none\"/&gt;&lt;/wfs:Feature&gt; &lt;/wfs:InsertResults&gt;&lt;/wfs:TransactionResponse&gt; 重新刷新页面后，再次点击查询按钮，可以验证之前修改的线段是否修改成功。由于不能提供geoserver服务器，所以只能让大家自行用下面的代码在本地验证： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;html&gt;&lt;head&gt; &lt;title&gt;wfs modify demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../ol3.17.1/ol.css\" type=\"text/css\" /&gt; &lt;script src=\"../ol3.17.1/ol-debug.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"../3rdparty/zepto.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"查询\" onclick=\"queryWfs();\" /&gt; &lt;input id=\"select\" type=\"checkbox\" value=\"select\" /&gt;选择 &lt;input id=\"modify\" type=\"checkbox\" value=\"modify\" /&gt;编辑 &lt;input id=\"save\" type=\"button\" value=\"保存\" onclick=\"onSave();\" /&gt; &lt;div id=\"map\" style=\"width:100%;height:100%;\"&gt;&lt;/div&gt; &lt;script&gt; var wfsVectorLayer = null; var modifiedFeatures = null; // 选择器 var selectInteraction = new ol.interaction.Select(&#123; style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', width: 2 &#125;) &#125;) &#125;); // 修改器 var modifyInteraction = new ol.interaction.Modify(&#123; style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', width: 5 &#125;) &#125;), features: selectInteraction.getFeatures() &#125;); modifyInteraction.on('modifyend', function(e) &#123; // 把修改完成的feature暂存起来 modifiedFeatures = e.features; &#125;); var map = new ol.Map(&#123; layers: [new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;)], target: 'map', view: new ol.View(&#123; center: [-73.99710639567148, 40.742270050255556], maxZoom: 19, zoom: 13, projection: 'EPSG:4326' &#125;) &#125;); // 通过wfs查询所有的要素 function queryWfs() &#123; // 支持重新查询 if (wfsVectorLayer) &#123; map.removeLayer(wfsVectorLayer); &#125; // 创建新的图层来加载wfs的要素 wfsVectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; format: new ol.format.GeoJSON(&#123; geometryName: 'the_geom' // 因为数据源里面字段the_geom存储的是geometry，所以需要指定 &#125;), url: 'http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326' &#125;), style: function(feature, resolution) &#123; return new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'blue', width: 5 &#125;) &#125;); &#125; &#125;); map.addLayer(wfsVectorLayer); &#125; $('#select').change(function() &#123; if (this.checked) &#123; // 勾选选择复选框时，添加选择器到地图 map.removeInteraction(selectInteraction); map.addInteraction(selectInteraction); &#125; else &#123; // 不勾选选择复选框的情况下，移出选择器和修改器 map.removeInteraction(selectInteraction); document.getElementById('modify').checked = false; map.removeInteraction(modifyInteraction); modifiedFeatures = null; &#125; &#125;); $('#modify').change(function() &#123; if (this.checked) &#123; // 勾选修改复选框时，添加选择器和修改器到地图 document.getElementById('select').checked = true; map.removeInteraction(modifyInteraction); map.addInteraction(modifyInteraction); map.removeInteraction(selectInteraction); map.addInteraction(selectInteraction); &#125; else &#123; // 不勾选修改复选框时，移出修改器 map.removeInteraction(modifyInteraction); modifiedFeatures = null; &#125; &#125;); // 保存已经编辑的要素 function onSave() &#123; if (modifiedFeatures &amp;&amp; modifiedFeatures.getLength() &gt; 0) &#123; // 转换坐标 var modifiedFeature = modifiedFeatures.item(0).clone(); // 注意ID是必须，通过ID才能找到对应修改的feature modifiedFeature.setId(modifiedFeatures.item(0).getId()); // 调换经纬度坐标，以符合wfs协议中经纬度的位置 modifiedFeature.getGeometry().applyTransform(function(flatCoordinates, flatCoordinates2, stride) &#123; for (var j = 0; j &lt; flatCoordinates.length; j += stride) &#123; var y = flatCoordinates[j]; var x = flatCoordinates[j + 1]; flatCoordinates[j] = x; flatCoordinates[j + 1] = y; &#125; &#125;); modifyWfs([modifiedFeature]); &#125; &#125; // 把修改提交到服务器端 function modifyWfs(features) &#123; var WFSTSerializer = new ol.format.WFS(); var featObject = WFSTSerializer.writeTransaction(null, features, null, &#123; featureType: 'nyc_roads', featureNS: 'http://geoserver.org/nyc_roads', // 注意这个值必须为创建工作区时的命名空间URI srsName: 'EPSG:4326' &#125;); // 转换为xml内容发送到服务器端 var serializer = new XMLSerializer(); var featString = serializer.serializeToString(featObject); var request = new XMLHttpRequest(); request.open('POST', 'http://localhost:8080/geoserver/wfs?service=wfs'); // 指定内容为xml类型 request.setRequestHeader('Content-Type', 'text/xml'); request.send(featString); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过wfs添加要素现在我们该介绍一下如何在前端绘制一个新的要素，并且保存到服务器端。还是先看一下界面： 勾选新增复选框之后，就可以在界面上绘制新的线段，如图，绘制了一个W形状的线，绘制完成后，点击按钮保存就可以把界面上新增的线保存到服务器端，在开发者工具界面可以看到http请求: http://localhost:8080/geoserver/wfs?service=wfs，请求发送的内容为：1234567891011121314151617181920212223242526&lt;Transaction xmlns=\"http://www.opengis.net/wfs\" service=\"WFS\" version=\"1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\"&gt; &lt;Insert&gt; &lt;nyc_roads xmlns=\"http://geoserver.org/nyc_roads\" fid=\"nyc_roads.new.1\"&gt; &lt;the_geom&gt; &lt;MultiLineString xmlns=\"http://www.opengis.net/gml\" srsName=\"EPSG:4326\"&gt; &lt;lineStringMember&gt; &lt;LineString srsName=\"EPSG:4326\"&gt; &lt;posList&gt;-73.99970054626465 40.732669830322266 -73.98974418640137 40.71481704711914 -73.98545265197754 40.730438232421875 -73.98064613342285 40.71636199951172 -73.97360801696777 40.73284149169922&lt;/posList&gt; &lt;/LineString&gt; &lt;/lineStringMember&gt; &lt;/MultiLineString&gt; &lt;/the_geom&gt; &lt;name&gt;nyc_roads.new.1&lt;/name&gt; &lt;modified&gt;nyc_roads.new.1&lt;/modified&gt; &lt;vsam&gt;0&lt;/vsam&gt; &lt;sourcedate&gt;&lt;/sourcedate&gt; &lt;sourcetype&gt;&lt;/sourcetype&gt; &lt;source_id&gt;1&lt;/source_id&gt; &lt;borough&gt;&lt;/borough&gt; &lt;feat_code&gt;0&lt;/feat_code&gt; &lt;feat_desc&gt;11&lt;/feat_desc&gt; &lt;feat_type&gt;0&lt;/feat_type&gt; &lt;exported&gt;true&lt;/exported&gt; &lt;/nyc_roads&gt; &lt;/Insert&gt;&lt;/Transaction&gt; 服务器端response的内容为：1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;wfs:TransactionResponse xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sf=\"http://www.openplans.org/spearfish\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:nyc_roads=\"http://geoserver.org/nyc_roads\" xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:ows=\"http://www.opengis.net/ows\" xmlns:tiger=\"http://www.census.gov\" xmlns:topp=\"http://www.openplans.org/topp\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.1.0\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://localhost:8080/geoserver/schemas/wfs/1.1.0/wfs.xsd\"&gt; &lt;wfs:TransactionSummary&gt; &lt;wfs:totalInserted&gt;1&lt;/wfs:totalInserted&gt; &lt;wfs:totalUpdated&gt;0&lt;/wfs:totalUpdated&gt; &lt;wfs:totalDeleted&gt;0&lt;/wfs:totalDeleted&gt; &lt;/wfs:TransactionSummary&gt; &lt;wfs:TransactionResults/&gt; &lt;wfs:InsertResults&gt; &lt;wfs:Feature&gt; &lt;ogc:FeatureId fid=\"new0\" /&gt; &lt;/wfs:Feature&gt; &lt;/wfs:InsertResults&gt; &lt;/wfs:TransactionResponse&gt; 通过再次刷新界面，点击查询按钮查看所有的feature，可以确认是否添加成功，请自行验证。下面给出对应的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;html&gt;&lt;head&gt; &lt;title&gt;wfs add demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../ol3.17.1/ol.css\" type=\"text/css\" /&gt; &lt;script src=\"../ol3.17.1/ol-debug.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"../3rdparty/zepto.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"查询\" onclick=\"queryWfs();\" /&gt; &lt;input id=\"add\" type=\"checkbox\" value=\"add\" /&gt;新增 &lt;input id=\"saveNew\" type=\"button\" value=\"保存\" onclick=\"onSaveNew();\" /&gt; &lt;div id=\"map\" style=\"width:100%;height:100%;\"&gt;&lt;/div&gt; &lt;script&gt; var newId = 1; var wfsVectorLayer = null; var drawedFeature = null; // 创建用于新绘制feature的layer var drawLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'blue', width: 5 &#125;) &#125;) &#125;); // 添加绘制新图形的interaction，用于添加新的线条 var drawInteraction = new ol.interaction.Draw(&#123; type: 'LineString', // 设定为线条 style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', width: 10 &#125;) &#125;), source: drawLayer.getSource() &#125;); drawInteraction.on('drawend', function(e) &#123; // 绘制结束时暂存绘制的feature drawedFeature = e.feature; &#125;); var map = new ol.Map(&#123; layers: [new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), drawLayer], target: 'map', view: new ol.View(&#123; center: [-73.99710639567148, 40.742270050255556], maxZoom: 19, zoom: 13, projection: 'EPSG:4326' &#125;) &#125;); function queryWfs() &#123; if (wfsVectorLayer) &#123; map.removeLayer(wfsVectorLayer); &#125; wfsVectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; format: new ol.format.GeoJSON(&#123; geometryName: 'the_geom' &#125;), url: 'http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326' &#125;), style: function(feature, resolution) &#123; return new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'blue', width: 5 &#125;) &#125;); &#125; &#125;); map.addLayer(wfsVectorLayer); &#125; $('#add').change(function() &#123; if (this.checked) &#123; // 勾选新增复选框时，添加绘制的Interaction map.removeInteraction(drawInteraction); map.addInteraction(drawInteraction); &#125; else &#123; // 取消勾选新增复选框时，移出绘制的Interaction，删除已经绘制的feature map.removeInteraction(drawInteraction); if (drawedFeature) &#123; drawLayer.getSource().removeFeature(drawedFeature); &#125; drawedFeature = null; &#125; &#125;); // 保存新绘制的feature function onSaveNew() &#123; // 转换坐标 var geometry = drawedFeature.getGeometry().clone(); geometry.applyTransform(function(flatCoordinates, flatCoordinates2, stride) &#123; for (var j = 0; j &lt; flatCoordinates.length; j += stride) &#123; var y = flatCoordinates[j]; var x = flatCoordinates[j + 1]; flatCoordinates[j] = x; flatCoordinates[j + 1] = y; &#125; &#125;); // 设置feature对应的属性，这些属性是根据数据源的字段来设置的 var newFeature = new ol.Feature(); newFeature.setId('nyc_roads.new.' + newId); newFeature.setGeometryName('the_geom'); newFeature.set('the_geom', null); newFeature.set('name', newFeature.getId()); newFeature.set('modified', newFeature.getId()); newFeature.set('vsam', 0); newFeature.set('sourcedate', ''); newFeature.set('sourcetype', ''); newFeature.set('source_id', newId); newFeature.set('borough', ''); newFeature.set('feat_code', 0); newFeature.set('feat_desc', '11'); newFeature.set('feat_type', 0); newFeature.set('exported', 'true'); newFeature.setGeometry(new ol.geom.MultiLineString([geometry.getCoordinates()])); addWfs([newFeature]); // 更新id newId = newId + 1; // 3秒后，自动刷新页面上的feature setTimeout(function() &#123; drawLayer.getSource().clear(); queryWfs(); &#125;, 3000); &#125; // 添加到服务器端 function addWfs(features) &#123; var WFSTSerializer = new ol.format.WFS(); var featObject = WFSTSerializer.writeTransaction(features, null, null, &#123; featureType: 'nyc_roads', featureNS: 'http://geoserver.org/nyc_roads', srsName: 'EPSG:4326' &#125;); var serializer = new XMLSerializer(); var featString = serializer.serializeToString(featObject); var request = new XMLHttpRequest(); request.open('POST', 'http://localhost:8080/geoserver/wfs?service=wfs'); request.setRequestHeader('Content-Type', 'text/xml'); request.send(featString); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过wfs删除要素删除feature是wfs协议中的最后一个例子了，和之前的修改，添加差不多，大同小异。还是先看界面： 选择查询按钮，把所有的feature加载到前端，然后勾选选择复选框，就可以在地图上选择要删除的feature，图示选择之前添加的W形状的线条，然后点击删除选中Feature按钮，就可以把feature删除掉。 在开发者工具窗口里面可以看到删除feature的http请求： http://localhost:8080/geoserver/wfs?service=wfs，其发送的内容为：1234567&lt;Transaction xmlns=\"http://www.opengis.net/wfs\" service=\"WFS\" version=\"1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd\"&gt; &lt;Delete typeName=\"feature:nyc_roads\" xmlns:feature=\"http://geoserver.org/nyc_roads\"&gt; &lt;Filter xmlns=\"http://www.opengis.net/ogc\"&gt; &lt;FeatureId fid=\"nyc_roads.1302\" /&gt; &lt;/Filter&gt; &lt;/Delete&gt;&lt;/Transaction&gt; 服务器端response的内容为：1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;wfs:TransactionResponse xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:sf=\"http://www.openplans.org/spearfish\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:nyc_roads=\"http://geoserver.org/nyc_roads\" xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:ows=\"http://www.opengis.net/ows\" xmlns:tiger=\"http://www.census.gov\" xmlns:topp=\"http://www.openplans.org/topp\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"1.1.0\" xsi:schemaLocation=\"http://www.opengis.net/wfs http://localhost:8080/geoserver/schemas/wfs/1.1.0/wfs.xsd\"&gt; &lt;wfs:TransactionSummary&gt; &lt;wfs:totalInserted&gt;0&lt;/wfs:totalInserted&gt; &lt;wfs:totalUpdated&gt;0&lt;/wfs:totalUpdated&gt; &lt;wfs:totalDeleted&gt;1&lt;/wfs:totalDeleted&gt; &lt;/wfs:TransactionSummary&gt; &lt;wfs:TransactionResults/&gt; &lt;wfs:InsertResults&gt; &lt;wfs:Feature&gt; &lt;ogc:FeatureId fid=\"none\" /&gt; &lt;/wfs:Feature&gt; &lt;/wfs:InsertResults&gt; &lt;/wfs:TransactionResponse&gt; 通过再次刷新查询，可以确认刚才的feature是否成功删除。请自行验证，对应实例的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;html&gt;&lt;head&gt; &lt;title&gt;wfs crud demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../ol3.17.1/ol.css\" type=\"text/css\" /&gt; &lt;script src=\"../ol3.17.1/ol-debug.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script src=\"../3rdparty/zepto.min.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"查询\" onclick=\"queryWfs();\" /&gt; &lt;input id=\"select\" type=\"checkbox\" value=\"select\" /&gt;选择 &lt;input id=\"delete\" type=\"button\" value=\"删除选中Feature\" onclick=\"onDeleteFeature();\" /&gt; &lt;div id=\"map\" style=\"width:100%;height:100%;\"&gt;&lt;/div&gt; &lt;script&gt; var wfsVectorLayer = null; // 选择器 var selectInteraction = new ol.interaction.Select(&#123; style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', width: 10 &#125;) &#125;) &#125;); var map = new ol.Map(&#123; layers: [new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;)], target: 'map', view: new ol.View(&#123; center: [-73.99710639567148, 40.742270050255556], maxZoom: 19, zoom: 13, projection: 'EPSG:4326' &#125;) &#125;); function queryWfs() &#123; if (wfsVectorLayer) &#123; map.removeLayer(wfsVectorLayer); &#125; wfsVectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; format: new ol.format.GeoJSON(&#123; geometryName: 'the_geom' &#125;), url: 'http://localhost:8080/geoserver/wfs?service=wfs&amp;version=1.1.0&amp;request=GetFeature&amp;typeNames=nyc_roads:nyc_roads&amp;outputFormat=application/json&amp;srsname=EPSG:4326' &#125;), style: function(feature, resolution) &#123; return new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'blue', width: 5 &#125;) &#125;); &#125; &#125;); map.addLayer(wfsVectorLayer); &#125; $('#select').change(function() &#123; if (this.checked) &#123; map.removeInteraction(selectInteraction); map.addInteraction(selectInteraction); &#125; else &#123; map.removeInteraction(selectInteraction); &#125; &#125;); function onDeleteFeature() &#123; // 删选择器选中的feature if (selectInteraction.getFeatures().getLength() &gt; 0) &#123; deleteWfs([selectInteraction.getFeatures().item(0)]); // 3秒后自动更新features setTimeout(function() &#123; selectInteraction.getFeatures().clear(); queryWfs(); &#125;, 3000); &#125; &#125; // 在服务器端删除feature function deleteWfs(features) &#123; var WFSTSerializer = new ol.format.WFS(); var featObject = WFSTSerializer.writeTransaction(null, null, features, &#123; featureType: 'nyc_roads', featureNS: 'http://geoserver.org/nyc_roads', srsName: 'EPSG:4326' &#125;); var serializer = new XMLSerializer(); var featString = serializer.serializeToString(featObject); var request = new XMLHttpRequest(); request.open('POST', 'http://localhost:8080/geoserver/wfs?service=wfs'); request.setRequestHeader('Content-Type', 'text/xml'); request.send(featString); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 常见问题","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch13/index.html","text":"常见问题 Q: ol3支持gif吗？ A: ol.style.Icon并不支持，但可以通过ol.Overlay来加载dom的方式支持。注意：在一个地图中如果存在几千个overlay，将影响效率。 Q: 地图缩小后，在一个页面出现多个一样的地图，如何才能只显示一个？ A: 在创建source的时候，设置wrapX属性为false就可以。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 Source和Layer","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch05/index.html","text":"Source和Layer在前面的例子中，已经对Source和Layer有所了解了。比如我们加载了Open Street Map的地图。然而世界上的地图并不只有Open Street Map，还有很多其他的地图，比如Google地图，天地图，高德地图，百度地图等。如果OpenLayers支持的地图来源越多，就会越适用，越强大。除了加载基本的地图之外，GIS还需要加载很多其他的信息，比如街道名称，商店名称，公交站点，道路等等。那么在OpenLayers 3中，具体该如何把这些添加在地图上呢？ 首先需要明白的一点是，Source和Layer是一对一的关系，有一个Source，必然需要一个Layer，然后把这个Layer添加到Map上，就可以显示出来了。通过官网的API搜索ol.source可以发现有很多不同的Source，但归纳起来共三种：ol.source.Tile，ol.source.Image和ol.source.Vector。 ol.source.Tile对应的是瓦片数据源，现在网页地图服务中，绝大多数都是使用的瓦片地图，而OpenLayers 3作为一个WebGIS引擎，理所当然应该支持瓦片。 ol.source.Image对应的是一整张图，而不像瓦片那样很多张图，从而无需切片，也可以加载一些地图，适用于一些小场景地图。 ol.source.Vector对应的是矢量地图源，点，线，面等等常用的地图元素(Feature)，就囊括到这里面了。这样看来，只要这两种Source就可以搞定80%的需求了。 从复杂度来分析，ol.source.Image和ol.source.Vector都不复杂，其数据格式和来源方式都简单。而ol.source.Tile则不一样，由于一些历史问题，多个服务提供商，多种标准等诸多原因，导致要支持世界上大多数的瓦片数据源，就需要针对这些差异提供不同的Tile数据源支持。在更进一步了解之前，我们先来看一下OpenLayers 3现在支持的Source具体有哪些： 上图中的类是按照继承关系，从左向右展开的，左边的为父类，右边的为子类。在使用时，一般来说，都是直接使用叶子节点上的类，基本就可以完成需求。父类需要自己进一步扩展或者处理才能有效使用的。 我们先了解最为复杂的ol.source.Tile，其叶子节点类有很多，大致可以分为几类： 在线服务的Source，包括ol.source.BingMaps(使用的是微软提供的Bing在线地图数据)，ol.source.MapQuest(使用的是MapQuest提供的在线地图数据)(注: 由于MapQuest开始收费，ol v3.17.0就移除了ol.source.MapQuest)，ol.source.OSM(使用的是Open Street Map提供的在线地图数据)，ol.source.Stamen(使用的是Stamen提供的在线地图数据)。没有自己的地图服务器的情况下，可直接使用它们，加载地图底图。 支持协议标准的Source，包括ol.source.TileArcGISRest，ol.source.TileWMS，ol.source.WMTS，ol.source.UTFGrid，ol.source.TileJSON。如果要使用它们，首先你得先学习对应的协议，之后必须找到支持这些协议的服务器来提供数据源，这些服务器可以是地图服务提供商提供的，也可以是自己搭建的服务器，关键是得支持这些协议。 ol.source.XYZ，这个需要单独提一下，因为是可以直接使用的，而且现在很多地图服务（在线的，或者自己搭建的服务器）都支持xyz方式的请求。国内在线的地图服务，高德，天地图等，都可以通过这种方式加载，本地离线瓦片地图也可以，用途广泛，且简单易学，需要掌握。 ol.source.Image虽然有几种不同的子类，但大多比较简单，因为不牵涉到过多的协议和服务器提供商。而ol.source.Vector就更加的简单了，但有时候其唯一的子类ol.source.Cluster在处理大量的Feature时，我们可能需要使用。 在大概了解了整个Source之后，紧接着该介绍它的搭档Layer了，同样的，我们还是先从OpenLayers 3现有的Layer类图大致了解一下： 为了便于了解和使用，图中标注了每一个Layer对应的Source。通过上图可以看到Layer相对于Source而言，真是太简单了。 对于初学者而言，如何选择和应用不同的Source和Layer是一个非常迷惑和困难的问题。为此，本章将围绕着Source和Layer展开，为大家解决这个问题。 加载瓦片地图瓦片地图源于一种大地图解决方案，针对一整块非常大的地图进行切片，分成很多相同大小的小块地图，在用户访问的时候，再一块一块小地图加载，拼接在一起，从而还原成一整块大的地图。这样做的优点在于，用户在同一时间，同一个可见视图内，只能看到地图的一部分，而不是全部。如果一次加载整个大地图，会导致加载很慢，且不可用的问题。这对于在线服务来说，是非常致命的。所以几乎所有的在线网页地图服务，都使用的是瓦片地图。自然加载瓦片地图成了必不可少的功能，也是必须要掌握的，为此本节将重点介绍如何选择和加载瓦片地图，不用担心，都会结合具体的实例来讲解。 最简单的加载在线地图本小节所介绍的这些在线地图，加载起来会非常简单，因为OpenLayers 3已经做了很好的封装，对于开发者而言，无须做过多的编码，即可直接使用。主要包括开源的Open Street Map，微软的Bing地图，Map Quest地图(注: 由于MapQuest开始收费，ol v3.17.0就移除了ol.source.MapQuest)，Stamen地图。 OpenStreetMap地图Bing地图Stamen地图MapQuest地图 // Open Street Map 地图层 var openStreetMapLayer = new ol.layer.Tile({ source: new ol.source.OSM() }); // Bing地图层 var bingMapLayer = new ol.layer.Tile({ source: new ol.source.BingMaps({ key: ‘AkjzA7OhS4MIBjutL21bkAop7dc41HSE0CNTR5c6HJy8JKc7U9U9RveWJrylD3XJ’, imagerySet: ‘Road’ }) }); // Stamen地图层 var stamenLayer = new ol.layer.Tile({ source: new ol.source.Stamen({ layer: ‘watercolor’ }) }); // MapQuest地图层 var mapQuestLayer = new ol.layer.Tile({ source: new ol.source.MapQuest({ layer: ‘osm’ }) }); // 创建地图 var map = new ol.Map({ layers: [ openStreetMapLayer ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: ‘EPSG:4326’, zoom: 10 }), target: ‘map’ }); function switch2OSM() { // 先移除当前的地图，再添加Open Street Map 地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(openStreetMapLayer); } function switch2BingMap() { // 先移除当前的地图，再添加Bing地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(bingMapLayer); } function switch2StamenMap() { // 先移除当前的地图，再添加stamen地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(stamenLayer); } function switch2MapQuest() { // 先移除当前的地图，再添加MapQuest地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(mapQuestLayer); }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;input type=\"radio\" checked=\"checked\" name=\"mapSource\" onclick=\"switch2OSM();\" /&gt;OpenStreetMap地图&lt;input type=\"radio\" name=\"mapSource\" onclick=\"switch2BingMap();\" /&gt;Bing地图&lt;input type=\"radio\" name=\"mapSource\" onclick=\"switch2StamenMap();\" /&gt;Stamen地图&lt;input type=\"radio\" name=\"mapSource\" onclick=\"switch2MapQuest();\" /&gt;MapQuest地图&lt;script&gt; // Open Street Map 地图层 var openStreetMapLayer = new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;); // Bing地图层 var bingMapLayer = new ol.layer.Tile(&#123; source: new ol.source.BingMaps(&#123; key: 'AkjzA7OhS4MIBjutL21bkAop7dc41HSE0CNTR5c6HJy8JKc7U9U9RveWJrylD3XJ', imagerySet: 'Road' &#125;) &#125;); // Stamen地图层 var stamenLayer = new ol.layer.Tile(&#123; source: new ol.source.Stamen(&#123; layer: 'watercolor' &#125;) &#125;); // MapQuest地图层 var mapQuestLayer = new ol.layer.Tile(&#123; source: new ol.source.MapQuest(&#123; layer: 'osm' &#125;) &#125;); // 创建地图 var map = new ol.Map(&#123; layers: [ openStreetMapLayer ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'map' &#125;); function switch2OSM() &#123; // 先移除当前的地图，再添加Open Street Map 地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(openStreetMapLayer); &#125; function switch2BingMap() &#123; // 先移除当前的地图，再添加Bing地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(bingMapLayer); &#125; function switch2StamenMap() &#123; // 先移除当前的地图，再添加stamen地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(stamenLayer); &#125; function switch2MapQuest() &#123; // 先移除当前的地图，再添加MapQuest地图 map.removeLayer(map.getLayers().item(0)); map.addLayer(mapQuestLayer); &#125;&lt;/script&gt;代码很简单，因为OpenLayers 3对这几个在线服务都做了很好的封装，只用简单的配置一下Source的构造参数就可以了。此处并没有列出每一个类的所有构造参数，但可以通过API文档查询了解。上面这个地图涉及到多个地图源，如果都放在地图上，就涉及到图层管理，这一部分的知识将在后续章节图层叠加及管理有更详细的介绍。# 万能瓦片地图加载秘籍其实加载瓦片地图基本是大同小异，你可能会觉得很惊讶，因为网上在线的地图服务，看起都不一样，本节即将为你解开这层神秘的面纱。在前面已基本介绍了瓦片地图的解决方案和作用，此处再用一张图来直观地认识一下瓦片结构：从上图可知，大家常用的瓦片地图是一个三维的概念，我们通常使用xyz这样的坐标来精确定位一张瓦片。通常z用于表示地图层级，而xy表示某个层级内的瓦片平面，x为横纵坐标，y为纵轴坐标，类似于数学上常见的笛卡尔坐标系。在这个瓦片平面上的每一个瓦片在横轴和纵轴上都有对应的坐标：x和y。## 加载简单的瓦片地图虽然现在大多数网页地图都使用的是瓦片地图，但还是有必要先介绍一下如何识别它。在浏览器中打开任意一个在线的网页地图，然后打开浏览器的开发者工具，再随意拖动，放大缩小地图。之后在开发者工具里查看新发起的请求，是否有一些图片请求，查看请求返回的图片，是否为正在浏览的地图的一部分，如果是，则基本为瓦片地图。下面以百度地图为例，说明一下在线瓦片地图请求信息：在请求的url中，我们可以很明显地看到xyz这三个参数，这进一步说明了百度地图就是用了瓦片地图。如果你多分析一下现有的在线网页地图，基本都是瓦片地图。正因为如此，OpenLayers 3提供了ol.source.XYZ这种通用的Source来适应广大的在线瓦片地图数据源，具备很好的适用性。通常情况下，开发者想要加载不同的在线瓦片地图源，则只需要更改ol.source.XYZ的构造参数中url就可以了。 比如我们就可以不用ol.source.OSM，而用ol.source.XYZ来加载Open Street Map地图，结果一样：12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;script&gt; // Open Street Map 地图层 var openStreetMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; url: 'http://&#123;a-c&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png' &#125;) &#125;); // 创建地图 var map = new ol.Map(&#123; layers: [ openStreetMapLayer ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'map' &#125;); &lt;/script&gt;&lt;/body&gt;除了Open Street Map可以这样加载外，还有很多其他的在线瓦片地图源也可以，比如高德地图：123456// 高德地图层var gaodeMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; url:'http://webst0&#123;1-4&#125;.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;' &#125;)&#125;);比如Yahoo地图：1234567// yahoo地图层var yahooMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; tileSize: 512, url:'https://&#123;0-3&#125;.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;/512/png8?lg=ENG&amp;ppi=250&amp;token=TrLJuXVK62IQk0vuXFzaig%3D%3D&amp;requestid=yahoo.prod&amp;app_id=eAdkWGYRoc4RfxVo0Z4B' &#125;)&#125;);大同小异，非常简单。上面的三个例子，只有Yahoo地图的代码有点不一样：多了tileSize参数的设置。默认情况下，tileSize为256，这也是现在绝大多数瓦片采用的大小。但Yahoo地图使用的是512，所以我们需要显示指定。## 瓦片地图之百度地图通过上面的示例我们已经发现，其实可以非常轻松地加载多种不同来源的在线瓦片地图。但遗憾地是，上面这种简单方法并不适用于所有的在线瓦片地图，总有一些是特殊的，比如百度地图，上面这种方式就不生效了。此时，我们需要回过头来思考一下瓦片地图加载的整个过程：瓦片地图加载的关键在于找对瓦片，但要找对瓦片，就得知道瓦片的坐标，而坐标又需要明确的坐标系。我们在坐标里说过，任何坐标都得有坐标系才有意义。在OpenLayers 3中，默认使用的瓦片地图的坐标系是如何定义的？经分析可知，OpenLayers 3的瓦片坐标系的原点在左上角，向上为y轴正方向，向右为x轴正方向。具体到地图上来讲，地球经过投影，投影到一个平面上，平面最左边对应地球最西边，平面最上边对应地球最北边。原点就处于整个平面的左上角，即地球的西北角，从北向南为y轴负方向，从西向东为x轴正方向。理解这一点非常重要，因为并不是所有在线的瓦片地图都是采用这样的坐标系。用OpenLayers 3加载它们的时候，如果坐标系不同，计算出来的瓦片地址就获取不到对应的瓦片，为解决这个问题，我们必须要先对瓦片坐标进行转换。那么，具体该怎么实现转换？最详细明了的方式还是看实例，下面我们看一下加载百度地图一种实现方式： // 百度地图层 var baiduMapLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ tilePixelRatio: 2, tileUrlFunction: function(tileCoord){ // 参数tileCoord为瓦片坐标 var z = tileCoord[0]; var x = tileCoord[1]; var y = tileCoord[2]; var halfTileNum = Math.pow(2, z-1); var baiduX = x - halfTileNum; var baiduY = y + halfTileNum; if (baiduX &lt; 0) { baiduX = ‘M’ + (-baiduX); } if (baiduY &lt; 0) { baiduY = ‘M’ + (-baiduY); } return ‘http://online2.map.bdimg.com/onlinelabel/?qt=tile&amp;x=‘ + baiduX + ‘&amp;y=’ + baiduY + ‘&amp;z=’ + z + ‘&amp;styles=pl&amp;udt=20160321&amp;scaler=2&amp;p=0’; } }) }); // 创建地图 var map = new ol.Map({ layers: [ baiduMapLayer ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: ‘EPSG:4326’, zoom: 4 }), target: ‘baiduMap’ });代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=\"baiduMap\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // 百度地图层 var baiduMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; tilePixelRatio: 2, tileUrlFunction: function(tileCoord)&#123; // 参数tileCoord为瓦片坐标 var z = tileCoord[0]; var x = tileCoord[1]; var y = tileCoord[2]; // 计算当前层级下瓦片总数的一半，用于定位整个地图的中心点 var halfTileNum = Math.pow(2, z-1); // 原点移到中心点后，计算xy方向上新的坐标位置 var baiduX = x - halfTileNum; var baiduY = y + halfTileNum; // 百度瓦片服务url将负数使用M前缀来标识 if (baiduX &lt; 0) &#123; baiduX = 'M' + (-baiduX); &#125; if (baiduY &lt; 0) &#123; baiduY = 'M' + (-baiduY); &#125; // 返回经过转换后，对应于百度在线瓦片的url return 'http://online2.map.bdimg.com/onlinelabel/?qt=tile&amp;x=' + baiduX + '&amp;y=' + baiduY + '&amp;z=' + z + '&amp;styles=pl&amp;udt=20160321&amp;scaler=2&amp;p=0'; &#125; &#125;) &#125;); // 创建地图 var map = new ol.Map(&#123; layers: [ baiduMapLayer ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 4 &#125;), target: 'baiduMap' &#125;);&lt;/script&gt;和前面几个加载在线瓦片地图的例子不一样的地方在于，我们没有设置url，而是设置了tileUrlFunction，这是一个获取瓦片url的函数，如果自定义这个函数，就可以实现不同坐标系之间的转换，从而返回在线地图服务对应瓦片的url。通过代码可以看到，函数入参是一个瓦片坐标，然后进行一系列的转换，得到百度在线地图的瓦片地址。效果参见上方地图，不妨拖动、缩放试试，拼接无缝，并没有什么问题。tileUrlFunction这个自定义函数的代码实现有可能看不懂，虽然知道在进行坐标转换，但并不知道为什么要这样实现。为了彻底弄明白代码，我们必须得把之前遗漏的一个很重要环节补上：弄明白待加载的在线瓦片地图的坐标系。对百度在线瓦片坐标系进行简单分析发现，它是以某一个位置为原点，向右为x正方向，向上为y正方向的坐标系，进一步分析发现，原点应该在中心位置，为此，我们假设百度地图是以经纬度[0,0]为原点，在此基础上编写函数tileUrlFunction的实现。halfTileNum表示的是在当前缩放层级之下，总的瓦片个数的一半，意味着它就是中心位置。对于baiduX小于0的情况，百度使用了M来表示负号，所以要特殊处理一下。想必这下应该更加理解代码实现了。不同的在线瓦片地图的转换代码可能不同，需要根据对应的坐标系来确定。但上面这个地图并不完美，因为我们设定的地图中心为成都，然而实际上显示的地图中心并不在成都。虽然无缝拼接，但位置偏差有点远。由此基本可以排除坐标转换的问题，看起来应该是OpenLayers 3的分辨率和百度在线瓦片地图使用的分辨率对不上。经过分析发现，确实如此，在网上也有很多分析文章可以查阅。那么我们是否可以重新定义分辨率呢？ 答案是肯定的，我们可以使用ol.source.XYZ的父类来解决问题。## 重新定义OpenLayers 3的瓦片坐标系ol.source.TileImage作为ol.source.XYZ的父类，除了可以转换坐标之外，还具备更加强大的功能，修改分辨率。下面我们使用它来加载百度地图，这次是正确的： // 自定义分辨率和瓦片坐标系 var resolutions = []; var maxZoom = 18; for(var i=0; i&lt;=maxZoom; i++){ resolutions[i] = Math.pow(2, maxZoom-i); } var tilegrid = new ol.tilegrid.TileGrid({ origin: [0,0], resolutions: resolutions }); // 创建百度地图的数据源 var baiduSource = new ol.source.TileImage({ projection: ‘EPSG:3857’, tileGrid: tilegrid, tileUrlFunction: function(tileCoord, pixelRatio, proj){ var z = tileCoord[0]; var x = tileCoord[1]; var y = tileCoord[2]; if(x&lt;0){ x = “M”+(-x); } if(y&lt;0){ y = “M”+(-y); } return “http://online3.map.bdimg.com/onlinelabel/?qt=tile&amp;x=&quot;+x+&quot;&amp;y=&quot;+y+&quot;&amp;z=&quot;+z+&quot;&amp;styles=pl&amp;udt=20160321&amp;scaler=2&amp;p=1“; } }); // 百度地图层 var baiduMapLayer2 = new ol.layer.Tile({ source: baiduSource }); // 创建地图 new ol.Map({ layers: [ baiduMapLayer2 ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: ‘EPSG:4326’, zoom: 10 }), target: ‘baiduMap2’ });对应的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div id=\"baiduMap2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // 自定义分辨率和瓦片坐标系 var resolutions = []; var maxZoom = 18; // 计算百度使用的分辨率 for(var i=0; i&lt;=maxZoom; i++)&#123; resolutions[i] = Math.pow(2, maxZoom-i); &#125; var tilegrid = new ol.tilegrid.TileGrid(&#123; origin: [0,0], // 设置原点坐标 resolutions: resolutions // 设置分辨率 &#125;); // 创建百度地图的数据源 var baiduSource = new ol.source.TileImage(&#123; projection: 'EPSG:3857', tileGrid: tilegrid, tileUrlFunction: function(tileCoord, pixelRatio, proj)&#123; var z = tileCoord[0]; var x = tileCoord[1]; var y = tileCoord[2]; // 百度瓦片服务url将负数使用M前缀来标识 if(x&lt;0)&#123; x = 'M' + (-x); &#125; if(y&lt;0)&#123; y = 'M' + (-y); &#125; return \"http://online0.map.bdimg.com/onlinelabel/?qt=tile&amp;x=\"+x+\"&amp;y=\"+y+\"&amp;z=\"+z+\"&amp;styles=pl&amp;udt=20160426&amp;scaler=1&amp;p=0\"; &#125; &#125;); // 百度地图层 var baiduMapLayer2 = new ol.layer.Tile(&#123; source: baiduSource &#125;); // 创建地图 new ol.Map(&#123; layers: [ baiduMapLayer2 ], view: new ol.View(&#123; // 设置成都为地图中心 center: ol.proj.transform([104.06, 30.67], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;), target: 'baiduMap2' &#125;);&lt;/script&gt;这个代码同上面的代码相比，引入了ol.tilegrid.TileGrid，由名字可见，这是定义瓦片网格，其实就是瓦片坐标系，构造时需要设定原点，紧接着设置分辨率，其作用在于设定每一地图层级的分辨率。我们是否遗漏了坐标系的正向和负向的设定？默认情况下，从左向右为x正方向，从下向上为y轴正方向。这和我们数学上通常定义的笛卡尔坐标系是一样的，这一点需要大家记住。如代码所示，就可以重新定义OpenLayers 3的瓦片地图坐标系，这种方式的代码比上一种方式更加的可读和简洁。 如果用通用的方法解决不了，请别忘记还有这一强大灵活的处理方式。## 分析瓦片地图坐标系如何分析不同在线瓦片地图的坐标系呢？非常重要的一点是，先从特例出发，找简单的情况分析，比如选择z为2或者3进行分析，这种情况下，瓦片的数量比较少，可以查看整个地球范围内的地图的瓦片请求，注意分析其请求的url参数。上述的所有地图都可以以这样的方式入手来分析，包括百度地图，可以自行尝试该方法。如果你有更好的方法，愿意的话，请给大家一起分享一下。## 解密瓦片url瓦片的url解析对于想直接使用在线瓦片服务的开发者而言，是一项经常要做的事。根据难度，大致可以分为三种情况： 第一种是最简单的，请求瓦片的url明确有xyz参数，比如高德地图和百度地图。 第二种稍微难一点，xyz作为路径直接存在于url里面，没有明确的参数表明哪些是xyz，比如Open Street Map和Yahoo地图，这种情况下，地图服务器接收到请求后，就直接在服务器按照这个路径获取图片，按照这个逻辑，一般第一个参数表示是z，第二个参数为x，第三个参数为y。要想确认是否真是这样，可以写一个小程序来验证一下，如果还有问题，建议按照上面分析地图坐标系中的方法，从z比较小的情况入手来分析x，y，z的位置。 第三种则最难，地图服务提供商为了防止大家直接非法使用瓦片地图，对瓦片的url进行了加密，比如现在的微软Bing中文地图和Google地图，这种情况下只有知道如何解密才能使用。## 加载微软Bing中文地图前面两种url的实例已经有了，此处分享一下第三种情况的url解密，以微软Bing中文地图为例：图中显示的瓦片地图请求的url，没有明显的xyz参数，最有可能的存放xyz参数的地方在于url前面那一串数字，真实情况确实是这样的，经过分析和解码，最终实现了加载Bing中文地图： // Bing中文地图层 var bingMapLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ tilePixelRatio: 2, tileUrlFunction: function(tileCoord){ var z = tileCoord[0]; var x = tileCoord[1]; var y = -tileCoord[2] - 1; var result=’’, zIndex=0; for(; zIndex&lt;z; zIndex++) { result = ((x&amp;1)+2(y&amp;1)).toString() + result; x &gt;&gt;= 1; y &gt;&gt;= 1; } return ‘http://dynamic.t0.tiles.ditu.live.com/comp/ch/‘ + result + ‘?it=G,VE,BX,L,LA&amp;mkt=zh-cn,syr&amp;n=z&amp;og=111&amp;ur=CN’; } }) }); // 创建地图 var map = new ol.Map({ layers: [ bingMapLayer ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: ‘EPSG:4326’, zoom: 10 }), target: ‘bingMap’ });代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"bingMap\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // Bing中文地图层 var bingMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; tileUrlFunction: function(tileCoord)&#123; var z = tileCoord[0]; var x = tileCoord[1]; var y = -tileCoord[2] - 1; var result='', zIndex=0; for(; zIndex&lt;z; zIndex++) &#123; result = ((x&amp;1)+2*(y&amp;1)).toString() + result; x &gt;&gt;= 1; y &gt;&gt;= 1; &#125; return 'http://dynamic.t0.tiles.ditu.live.com/comp/ch/' + result + '?it=G,VE,BX,L,LA&amp;mkt=zh-cn,syr&amp;n=z&amp;og=111&amp;ur=CN'; &#125; &#125;) &#125;); // 创建地图 var map = new ol.Map(&#123; layers: [ bingMapLayer ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'bingMap' &#125;);&lt;/script&gt;需要注意的是地图数据是非常昂贵的，如果使用某一个在线地图服务，请先核实对方的版权和数据使用申明，不要侵犯对方的权益，按照要求合法使用地图。几乎所有的在线地图服务都提供了响应的服务接口，强烈建议在商用项目中使用这些接口。对于这些接口的使用，服务商都有详细的说明，在此不累述。# google地图加载有许多人都在问google地图加载的问题，因为地图url是加密的，通过分析url，可以采用下面的方式来加载： // google地图层 var googleMapLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ url:’http://www.google.cn/maps/vt/pb=!1m4!1m3!1i{z}!2i{x}!3i{y}!2m3!1e0!2sm!3i345013117!3m8!2szh-CN!3scn!5e1105!12m4!1e68!2m2!1sset!2sRoadmap!4e0‘ }) }); // 创建地图 var map = new ol.Map({ layers: [ googleMapLayer ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: ‘EPSG:4326’, zoom: 10 }), target: ‘googleMap’ });代码如下：1234567891011121314151617181920212223&lt;div id=\"googleMap\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // google地图层 var googleMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; url:'http://www.google.cn/maps/vt/pb=!1m4!1m3!1i&#123;z&#125;!2i&#123;x&#125;!3i&#123;y&#125;!2m3!1e0!2sm!3i345013117!3m8!2szh-CN!3scn!5e1105!12m4!1e68!2m2!1sset!2sRoadmap!4e0' &#125;) &#125;); // 创建地图 var map = new ol.Map(&#123; layers: [ googleMapLayer ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'googleMap' &#125;);&lt;/script&gt;至此，关于通用瓦片地图加载的秘籍就介绍完毕，希望大家都掌握了。# 加载离线瓦片地图其实离线瓦片地图和在线瓦片地图是一样的原理，都是瓦片，只是离线瓦片地图的存取方式，是由开发者自己来定义的，而在线瓦片地图则不一定。 在不理解原理的情况下，很多人拥有了离线瓦片，却不知道如何加载，所以这里单独列出一个小节来讲解。在很早之前，我在github上放出了一个加载离线瓦片的地图demo，现在还是使用这个demo来讲解： // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center = ol.proj.transform([104.06667, 30.66667], ‘EPSG:4326’, ‘EPSG:3857’); //创建地图 var map = new ol.Map({ view: new ol.View({ center: center, zoom: 4 }), target: ‘map’ }); // 添加一个使用离线瓦片地图的层 var offlineMapLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ // 设置本地离线瓦片所在路径，由于例子里面只有一张瓦片，页面显示时就只看得到一张瓦片。 url: ‘../src/05-04/offlineMapTiles/{z}/{x}/{y}.png’ }) }); map.addLayer(offlineMapLayer);只是演示效果，所以瓦片就只有1张。 如果放大或者缩小，就可能看不到地图瓦片了。 先看代码：12345678910111213141516171819202122232425&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center = ol.proj.transform([104.06667, 30.66667], 'EPSG:4326', 'EPSG:3857'); //创建地图 var map = new ol.Map(&#123; view: new ol.View(&#123; center: center, zoom: 4 &#125;), target: 'map' &#125;); // 添加一个使用离线瓦片地图的层 var offlineMapLayer = new ol.layer.Tile(&#123; source: new ol.source.XYZ(&#123; // 设置本地离线瓦片所在路径，由于例子里面只有一张瓦片，页面显示时就只看得到一张瓦片。 url: '../src/05-04/offlineMapTiles/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png' &#125;) &#125;); map.addLayer(offlineMapLayer);&lt;/script&gt;代码很简单，就不再做任何说明，参照注释。 这个例子中唯一的瓦片图片相对路径是： offlineMapTiles/4/12/6.png。 在开发时，会考虑这样一个问题： 是先在代码里面写url，还是先在本地放好瓦片地图？ 我建议瓦片地图数据优先，而且很多瓦片地图都是工具下载的，量大，如果需要修改目录结构，会比较费事。相对的，修改url的代码明显就要简单很多。url必须根据瓦片地图存放路径来编写，比如这个例子里面，4表示的是层级，12表示的是x，6表示的是y，我们的url参数就写成： {z}/{x}/{y}.png。 如果瓦片地图都放在一个目录下，采用z-x-y.png的方式命名，那么url参数就得写成： {z}-{x}-{y}.png。在上一节中，我们提到过，瓦片地图最主要的是要考虑瓦片的坐标系和分辨率，对于离线瓦片地图也同样成立。 在使用之前，你必须要了解清楚这一点，方能正确加载和使用。## 常见问题&gt; Q: 为什么本地有离线瓦片地图，但在网页中没有显示地图？&gt; A: 存在多种原因可能导致这个问题的出现，你需要逐一检查：&gt; 打开开发者工具，检查一下代码是否有错误提示。&gt; 检查一下HTTP请求的瓦片地址是否正确。&gt; 检查一下离线瓦片地图，是否包含了当前地图显示层级的瓦片地图。&gt; 检查一下离线瓦片地图的整个区域，是否包含了当前地图设置的中心点。&gt; 检查一下地图使用的坐标系，是否正确。 OpenLayers 3默认使用的是mercator，而不是wgs84。所以如果中心点想设置为经度30度，纬度30度，就需要显示设置projection: &#39;EPSG:4326&#39;，或者使用ol.proj.transform([30, 30], &#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;)进行转换。同一个坐标，不同的坐标系，位置可能截然不同。&gt; Q: 为什么加载的地图有瓦片错位，拼接不上？&gt; A: 检查一下离线瓦片地图的坐标系，是否和OpenLayers 3默认的坐标系不一致，如果不一致，请按照上一小节的处理方式处理。# 静态地图及应用此处说的静态地图指没有经过地理投影什么的普通地图，比如一些规划图，室内建筑图，平面示意图等等，这些图一般都不会很大，但常用于一些演示系统中。 会涉及到一些简单的定位，标注等。 OpenLayers 3也充分考虑到了这样的需求，提供了对应的source类： ol.source.ImageStatic。 示例请看下面这个地图，显示的是成都熊猫基地的平面图： // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center = ol.proj.transform([104.06667, 30.66667], ‘EPSG:4326’, ‘EPSG:3857’); // 计算熊猫基地地图映射到地图上的范围，图片像素为 550344，保持比例的情况下，把分辨率放大一些 var extent = [center[0]- 5501000/2, center[1]-3441000/2, center[0]+5501000/2, center[1]+3441000/2]; //创建地图 var map = new ol.Map({ view: new ol.View({ center: center, zoom: 7 }), target: ‘map’ }); // 加载熊猫基地静态地图层 map.addLayer(new ol.layer.Image({ source: new ol.source.ImageStatic({ url: ‘../img/pandaBase.jpg’, // 熊猫基地地图 imageExtent: extent // 映射到地图的范围 }) }));因为应用于OpenLayers 3中，所以地图可以放大缩小，具备相应的功能，对于演示而言，无疑加快了开发效率。 对应的代码如下：12345678910111213141516171819202122232425&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center = ol.proj.transform([104.06667, 30.66667], 'EPSG:4326', 'EPSG:3857'); // 计算熊猫基地地图映射到地图上的范围，图片像素为 550*344，保持比例的情况下，把分辨率放大一些 var extent = [center[0]- 550*1000/2, center[1]-344*1000/2, center[0]+550*1000/2, center[1]+344*1000/2]; //创建地图 var map = new ol.Map(&#123; view: new ol.View(&#123; center: center, zoom: 7 &#125;), target: 'map' &#125;); // 加载熊猫基地静态地图层 map.addLayer(new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: '../img/pandaBase.jpg', // 熊猫基地地图 imageExtent: extent // 映射到地图的范围 &#125;) &#125;));&lt;/script&gt;代码中有详细注释，可帮助理解，要应用静态地图，需要注意设置图片在地图中占据的extent。 如果没有这个设置，图片就不能和位置关联在一起，也就不能应用于OpenLayers 3中。 大家肯定非常关心extent的计算[center[0]- 550*1000/2, center[1]-344*1000/2, center[0]+550*1000/2, center[1]+344*1000/2]，为什么这样计算？ 这个地方我想让图片本身的大小和地理范围产生联系，图片的大小为550344像素，在此基础上同比放大1000倍，作地理范围。当然也可以不用放大，直接作为地理范围，只是这样需要放大地图到很高的层级才能看到它。 有了这样的映射关系后，图片能保持长宽比不变，从而不变形。 为什么引入center，除以2相关的计算？ 这是一个简单计算，目的在于设置图片显示在地图中心。把地图加载出来只是第一步，我们最重要的是在地图上定位，并处理相应的业务。比如我们希望在图片[390,145]像素位置添加一个活动图标表示这个地方有现场活动，就像下面这样： // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center2 = ol.proj.transform([104.06667, 30.66667], ‘EPSG:4326’, ‘EPSG:3857’); // 计算熊猫基地地图映射到地图上的范围，图片像素为 550344，保持比例的情况下，把分辨率放大一些 var extent2 = [center[0]- 5501000/2, center[1]-3441000/2, center[0]+5501000/2, center[1]+3441000/2]; //创建地图 var map2 = new ol.Map({ view: new ol.View({ center: center, zoom: 7 }), target: ‘map2’ }); // 加载熊猫基地静态地图层 map2.addLayer(new ol.layer.Image({ source: new ol.source.ImageStatic({ url: ‘../img/pandaBase.jpg’, // 熊猫基地地图 imageExtent: extent2 // 映射到地图的范围 }) })); var activityLayer = new ol.layer.Vector({ source: new ol.source.Vector() }); var activity = new ol.Feature({ geometry: new ol.geom.Point([center[0]- 5501000/2 + 390 1000, center[1]-3441000/2 + (344 - 145) 1000]) }) activity.setStyle(new ol.style.Style({ image: new ol.style.Icon({ src: ‘../img/flag_right.png’, anchor: [0, 1], scale: 0.2 }) })); activityLayer.getSource().addFeature(activity); map2.addLayer(activityLayer);看到地图上的小旗帜没有，它就是新加上去的活动图标。 那么我们是如何做到的呢：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 地图设置中心，设置到成都，在本地离线地图 offlineMapTiles刚好有一张zoom为4的成都瓦片 var center2 = ol.proj.transform([104.06667, 30.66667], 'EPSG:4326', 'EPSG:3857'); // 计算熊猫基地地图映射到地图上的范围，图片像素为 550*344，保持比例的情况下，把分辨率放大一些 var extent2 = [center[0]- 550*1000/2, center[1]-344*1000/2, center[0]+550*1000/2, center[1]+344*1000/2]; //创建地图 var map2 = new ol.Map(&#123; view: new ol.View(&#123; center: center, zoom: 7 &#125;), target: 'map2' &#125;); // 加载熊猫基地静态地图层 map2.addLayer(new ol.layer.Image(&#123; source: new ol.source.ImageStatic(&#123; url: '../img/pandaBase.jpg', // 熊猫基地地图 imageExtent: extent2 // 映射到地图的范围 &#125;) &#125;)); // 创建一个用于放置活动图标的layer var activityLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;); // 创建一个活动图标需要的Feature，并设置位置 var activity = new ol.Feature(&#123; geometry: new ol.geom.Point([center[0]- 550*1000/2 + 390 * 1000, center[1]-344*1000/2 + (344 - 145) * 1000]) &#125;) // 设置Feature的样式，使用小旗子图标 activity.setStyle(new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/flag_right.png', anchor: [0, 1], scale: 0.2 &#125;) &#125;)); // 添加活动Feature到layer上，并把layer添加到地图中 activityLayer.getSource().addFeature(activity); map2.addLayer(activityLayer);&lt;/script&gt;注释足够帮助大家理解代码意图，我想最关键的在于activity这个feature的位置为什么要这样计算： [center[0]- 550*1000/2 + 390 * 1000, center[1]-344*1000/2 + (344 - 145) * 1000]。 如果翻译成下面这样，你可能会更容易理解：extentLeft+picX, extentTop+picY，此处的picX和picY显然是需要在图片像素位置的基础上放大1000倍，才能对应于地理位置。 [center[0]- 550*1000/2对应的就是extentLeft, center[1]-344*1000/2对应的是extentBottom，并不是extentTop，所以我们要做一个简单的计算(344 - 145) * 1000，而不是直接用145*1000。从图片的像素坐标转换为地图的地理坐标，关键在于通过像素大小，映射到一个地理的extent，希望能理解这个过程。 在此基础上，就能充分应用OpenLayers 3的功能了。对于图片比较大的情况，可以自行切片，然后分片加载，从而拼成一整张地图，可按照上面的方法自行尝试，作为课后练习。# 加载WMS服务地图# 矢量地图矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真。在地图中存在着大量的应用，是地图数据中非常重要的组成部分。为了便于存储，传递，使用，矢量地图会按照一定的格式来表达，比如常见的GeoJSON，TopoJSON，GML，KML，ShapeFile等等。 除了最后一个ShapeFile，其他几个格式的矢量地图OpenLayers 3都支持，使用起来也是非常的简单，下面这个地图就加载了GeoJSON格式的矢量地图。 //创建地图 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), new ol.layer.Vector({ source: new ol.source.Vector({ url: ‘../data/geojson/line-samples.geojson’, format: new ol.format.GeoJSON() }) }) ], view: new ol.View({ center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: ‘EPSG:4326’ }), target: ‘map’ });代码非常简单：1234567891011121314151617181920212223242526&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建地图 var map = new ol.Map(&#123; layers: [ // 底图用Open Street Map 地图 new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), // 再加载一个geojson的矢量地图 new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; url: '../data/geojson/line-samples.geojson', // 地图来源 format: new ol.format.GeoJSON() // 解析矢量地图的格式化类 &#125;) &#125;) ], view: new ol.View(&#123; center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: 'EPSG:4326' &#125;), target: 'map' &#125;);&lt;/script&gt;注释对代码进行了很好的说明，但有两点需要进一步说明： 加载矢量图使用的source是ol.source.Vector, layer是ol.layer.Vector，不要错误的使用。 加载代码之所以这么简单，是因为OpenLayers 3内置了对应矢量地图格式的解析类，比如ol.format.GeoJSON。 它们都位于包ol.format下面，可以在API官方文档中查询得到。 如果是shapefile这种不支持的，则需要自己解析。 解析后，矢量地图都会转换为对应于OpenLayers 3中的feature。 所以，当加载完成后，可以通过source的getFeatures方法来获取所有的矢量图形。 需要注意坐标系，因为.geojson文档里用的是和当前地图用的不一样的坐标系。对于不同格式的矢量地图，会有相应的一些不同用法，下面就针对一些大家经常会遇到的问题，给出相应的实例，用以说明。# 获取加载后的所有feature这是一个很多人会遇到的问题，因为在加载矢量地图后，需要对矢量地图做一些简单的查询，分析等。 但是经常会遇到获取不到加载后的feature的问题。 原因就在于获取的时机不对，因为矢量地图是异步加载的。 下面就看一下正确的获取所有feature的做法是什么： 矢量地图Feature总数： //创建地图 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], view: new ol.View({ center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: ‘EPSG:4326’ }), target: ‘map’ }); var vectorLayer = new ol.layer.Vector({ source: new ol.source.Vector({ url: ‘../data/geojson/line-samples.geojson’, format: new ol.format.GeoJSON() }) }); var listenerKey = vectorLayer.getSource().on(‘change’, function(){ if (vectorLayer.getSource().getState() === ‘ready’) { document.getElementById(‘count’).innerHTML = vectorLayer.getSource().getFeatures().length; vectorLayer.getSource().unByKey(listenerKey); } }); map.addLayer(vectorLayer);从图上可以看到，共有9个feature， 在地图下方的统计数据也是9。 下面看看代码是如何实现的：12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;div&gt;矢量地图Feature总数： &lt;span id=\"count\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建地图 var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], view: new ol.View(&#123; center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: 'EPSG:4326' &#125;), target: 'map' &#125;); var vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; url: '../data/geojson/line-samples.geojson', format: new ol.format.GeoJSON() &#125;) &#125;); // 因为是异步加载，所以要采用事件监听的方式来判定是否加载完成 var listenerKey = vectorLayer.getSource().on('change', function()&#123; if (vectorLayer.getSource().getState() === 'ready') &#123; // 判定是否加载完成 document.getElementById('count').innerHTML = vectorLayer.getSource().getFeatures().length; vectorLayer.getSource().unByKey(listenerKey); // 注销监听器 &#125; &#125;); map.addLayer(vectorLayer); // 如果在此处调用vectorLayer.getSource().getFeatures()是完全有可能获取不到任何Feature的，这是常犯错误&lt;/script&gt;对于其他格式的矢量地图加载也需要这样编写代码，才能正确获取到加载完成的所有feature。# 坐标转换坐标转换也是矢量地图经常会遇到的问题，比如当前地图用的是EPSG:3857，但是矢量地图用的是EPSG:4326，这样就需要进行坐标转换。 由于OpenLayers 3为我们内置了地图格式解析器，那么自然只能依靠它来处理。 上一节中使用的.geojson文件内的坐标使用的是wgs84坐标，那么如果我们地图使用EPSG:3857，该怎么来加载？ //创建地图 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), ], view: new ol.View({ center: ol.proj.fromLonLat([-72.980624870461128, 48.161307640513321]), zoom: 8 }), target: ‘map’ }); function addGeoJSON(src) { var layer = new ol.layer.Vector({ source: new ol.source.Vector({ features: (new ol.format.GeoJSON()).readFeatures(src, { dataProjection: ‘EPSG:4326’, featureProjection: ‘EPSG:3857’ }) }) }); map.addLayer(layer); } $.ajax({ url: ‘../data/geojson/line-samples.geojson’, success: function(data, status) { addGeoJSON(data); } });详细实现参见代码：12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建地图 var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), ], view: new ol.View(&#123; center: ol.proj.fromLonLat([-72.980624870461128, 48.161307640513321]), zoom: 8 &#125;), target: 'map' &#125;); // 加载矢量地图 function addGeoJSON(src) &#123; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; features: (new ol.format.GeoJSON()).readFeatures(src, &#123; // 用readFeatures方法可以自定义坐标系 dataProjection: 'EPSG:4326', // 设定JSON数据使用的坐标系 featureProjection: 'EPSG:3857' // 设定当前地图使用的feature的坐标系 &#125;) &#125;) &#125;); map.addLayer(layer); &#125; // 使用ajax获取矢量地图数据 $.ajax(&#123; url: '../data/geojson/line-samples.geojson', success: function(data, status) &#123; // 成功获取到数据内容后，调用方法添加到地图 addGeoJSON(data); &#125; &#125;);&lt;/script&gt;代码稍微麻烦了一点，是因为目前ol.format.GeoJSON的构造参数不支持设定创建feature的坐标系，如果要支持也并不麻烦，期望后续官网能够改进。注意，该方法可以适用于其他几种矢量地图。readFeatures这个方法在内置的几个解析类中都有。# 样式设置对矢量元素进行样式设置，OpenLayers3 支持两种方式，一种是直接给feature设置样式，一种是给layer设置样式。系统默认优先考虑feature的样式，如果没有，则使用layer的样式，还有一种情况是layer也没有设置样式，则会采用系统默认的样式。对于矢量地图而言，要想修改样式也只有这两种途径可选。比如之前例子中使用的GeoJSON，如果要改变线条的颜色成下面这样，可以考虑在layer上设置样式： //创建地图 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], view: new ol.View({ center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: ‘EPSG:4326’ }), target: ‘map’ }); var vectorLayer = new ol.layer.Vector({ source: new ol.source.Vector({ url: ‘../data/geojson/line-samples.geojson’, format: new ol.format.GeoJSON() }), style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: ‘red’, size: 1 }) }) }); map.addLayer(vectorLayer);代码很简单：12345678910111213141516171819202122232425262728293031323334&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //创建地图 var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], view: new ol.View(&#123; center: [-72.980624870461128, 48.161307640513321], zoom: 8, projection: 'EPSG:4326' &#125;), target: 'map' &#125;); var vectorLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(&#123; url: '../data/geojson/line-samples.geojson', format: new ol.format.GeoJSON() &#125;), // 设置样式，颜色为红色，线条粗细为1个像素 style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;); map.addLayer(vectorLayer);&lt;/script&gt;如果要在feature上设置样式，就必须先获取到所有加载的feature，然后依次设置，显然直接设置layer的样式，会在代码编写上更容易一些。## 自带样式的矢量地图修改样式有些矢量地图数据自带样式，比如KML格式的矢量地图，如果要修改样式，则相对比较麻烦。得分情况考虑： 一种是所有矢量地图都不使用自带的样式；* 一种是部分矢量地图不使用自带的样式。对于第一种情况，则相对比较简单一些，只需要把ol.format.KML的构造参数extractStyles设置为false即可，然后为layer设定自定义的样式。对于第二种情况，则相对麻烦一些，必须要读取加载的所有feature，并进行过滤，对符合条件的feature重新设置样式。# 图层叠加及管理分层管理是GIS渲染引擎及其他图形系统常用的策略，为业务的应用提高了较大的适用性。比如更换地图底图，不能影响在上地图上添加的一些标注。如果把地图底图和标注分开，放在不同的图层上，就很容易解决这个问题。有了图层的概念，自然需要对图层进行控制，比如增删改查等，图层之间的顺序，图层可见度等等。这些都是大家经常会遇到的问题。下面先来看一下三个图层叠加的情况： 显示/隐藏： 底图 圆 点 图层顺序： 底图最上 圆最上 点最上 // 创建3个图层 var osmLayer = new ol.layer.Tile({ source: new ol.source.OSM() }); var pointLayer = new ol.layer.Vector({ source: new ol.source.Vector() }); var circleLayer = new ol.layer.Vector({ source: new ol.source.Vector() }); var map = new ol.Map({ layers: [osmLayer, pointLayer, circleLayer], view: new ol.View({ center: [0, 0], zoom: 2 }), target: ‘map’ }); // 添加点 var point = new ol.Feature({ geometry: new ol.geom.Point([0, 0]) }); point.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 1, fill: new ol.style.Fill({ color: ‘red’ }), stroke: new ol.style.Stroke({ color: ‘red’, size: 1 }) }) })); pointLayer.getSource().addFeature(point); // 添加圆 var circle = new ol.Feature({ geometry: new ol.geom.Point([0, 0]) }); circle.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 10, stroke: new ol.style.Stroke({ color: ‘blue’, size: 1 }) }) })); circleLayer.getSource().addFeature(circle); function checkOsm(elem) { osmLayer.setVisible(elem.checked); } function checkPoint(elem) { pointLayer.setVisible(elem.checked); } function checkCircle(elem) { circleLayer.setVisible(elem.checked); } function upOsm (elem) { if (elem.checked) { osmLayer.setZIndex(3); circleLayer.setZIndex(circleLayer.getZIndex()-1); pointLayer.setZIndex(pointLayer.getZIndex()-1); } } function upCircle (elem) { if (elem.checked) { circleLayer.setZIndex(3); osmLayer.setZIndex(osmLayer.getZIndex()-1); pointLayer.setZIndex(pointLayer.getZIndex()-1); } } function upPoint(elem) { if (elem.checked) { pointLayer.setZIndex(3); osmLayer.setZIndex(osmLayer.getZIndex()-1); circleLayer.setZIndex(circleLayer.getZIndex()-1); } } 上面这个地图示范了显示和隐藏的控制，以及图层顺序的控制。可以勾选上面的复选框和单选框试试。具体实现，参见下面的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;div&gt; 显示/隐藏： &lt;input type=\"checkbox\" checked=\"checked\" onclick=\"checkOsm(this);\" /&gt;底图 &lt;input type=\"checkbox\" checked=\"checked\" onclick=\"checkCircle(this);\"/&gt;圆 &lt;input type=\"checkbox\" checked=\"checked\" onclick=\"checkPoint(this);\"/&gt;点&lt;/div&gt;&lt;div&gt; 图层顺序： &lt;input name=\"seq\" type=\"radio\" value=\"\" onclick=\"upOsm(this);\" /&gt;底图最上 &lt;input name=\"seq\" type=\"radio\" value=\"\" checked=\"checked\" onclick=\"upCircle(this);\"/&gt;圆最上 &lt;input name=\"seq\" type=\"radio\" value=\"\" onclick=\"upPoint(this);\"/&gt;点最上&lt;/div&gt;&lt;script&gt; // 创建3个图层 var osmLayer = new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;); var pointLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;); var circleLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;); new ol.Map(&#123; // 在地图上添加上面创建的三个图层，图层顺序自下而上，依次是osm，point，circle layers: [osmLayer, pointLayer, circleLayer], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map' &#125;); // 添加点 var point = new ol.Feature(&#123; geometry: new ol.geom.Point([0, 0]) &#125;); point.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 1, fill: new ol.style.Fill(&#123; color: 'red' &#125;), stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;)); pointLayer.getSource().addFeature(point); // 添加圆 var circle = new ol.Feature(&#123; geometry: new ol.geom.Point([0, 0]) &#125;); circle.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, stroke: new ol.style.Stroke(&#123; color: 'blue', size: 1 &#125;) &#125;) &#125;)); circleLayer.getSource().addFeature(circle); // 隐藏显示osm图层 function checkOsm(elem) &#123; osmLayer.setVisible(elem.checked); &#125; // 隐藏显示point图层 function checkPoint(elem) &#123; pointLayer.setVisible(elem.checked); &#125; // 隐藏显示circle图层 function checkCircle(elem) &#123; circleLayer.setVisible(elem.checked); &#125; // 置顶osm图层到最上面 function upOsm (elem) &#123; if (elem.checked) &#123; osmLayer.setZIndex(3); circleLayer.setZIndex(circleLayer.getZIndex()-1); pointLayer.setZIndex(pointLayer.getZIndex()-1); &#125; &#125; // 置顶circle图层到最上面 function upCircle (elem) &#123; if (elem.checked) &#123; circleLayer.setZIndex(3); osmLayer.setZIndex(osmLayer.getZIndex()-1); pointLayer.setZIndex(pointLayer.getZIndex()-1); &#125; &#125; // 置顶point图层到最上面 function upPoint(elem) &#123; if (elem.checked) &#123; pointLayer.setZIndex(3); osmLayer.setZIndex(osmLayer.getZIndex()-1); circleLayer.setZIndex(circleLayer.getZIndex()-1); &#125; &#125;&lt;/script&gt; 简而言之，就是可以利用方法setVisible和setZIndex来控制图层，满足80%的这种需求。 除此之外，大家也可以使用很早之前使用的一种方式来实现管理，即删除/添加图层，参见最简单的加载在线地图。 openlayers3瓦片加载的源码浅析与小结–感谢作者：老羽 (QQ：274103592, 邮箱：michael.zy@163.com, 简书：老羽 ) 一、类图与逻辑 上图中列了关于瓦片图层加载相关的重要方法。 Map对象初始化时根据options.renderer创建ol.renderer.Map的实例，默认是ol.renderer.canvas.Map； ol.render.canvas.Map实现了抽象方法createLayerRenderer，这是一个简单工厂，根据不同的图层创建对应的ol.renderer.Layer。其中ol.layer.Tile对应的就是ol.renderer.canvas.TileLayer； ol.renderer.canvas.TileLayer.prepareFrame调用source对应的TileGrid.getTileRangeForExtentAndResolution获取可视范围内的瓦片范围，并循环遍历加载瓦片； TileGrid在初始化时就计算出了对应layer的所有瓦片范围： calculateTileRanges-》循环遍历resolutions，调用getTileRangeForExtentAndZ，根据extent计算瓦片范围； getTileRangeForExtentAndResolution计算瓦片的范围： 1234567891011121314151617181920212223242526272829303132333435363738394041424344ol.tilegrid.TileGrid.prototype.getTileRangeForExtentAndResolution = function( extent, resolution, opt_tileRange) &#123; var tileCoord = ol.tilegrid.TileGrid.tmpTileCoord_; // 根据extent的左下角的计算瓦片坐标； this.getTileCoordForXYAndResolution_( extent[0], extent[1], resolution, false, tileCoord); var minX = tileCoord[1]; var minY = tileCoord[2]; // 根据extent的右上角的计算瓦片坐标； this.getTileCoordForXYAndResolution_( extent[2], extent[3], resolution, true, tileCoord); // 得到某个resolution级别下的瓦片范围（左下角瓦片坐标 - 右上角瓦片坐标） return ol.TileRange.createOrUpdate( minX, tileCoord[1], minY, tileCoord[2], opt_tileRange); &#125;;// 根据extent左下角及右上角的坐标-origin后得到地图的长宽 / resolution得到像素值；// 然后 / tileSize 得到需要多少张瓦片；// 当计算extent右上角的瓦片坐标时，因为瓦片坐标是从0开始计算，当瓦片数量为例如1.5此类小数时，// 应该是2张瓦片，从0开始计算，那么XY就应该向下取整，取1；0，1两张瓦片；ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndResolution_ = function( x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) &#123; var z = this.getZForResolution(resolution); var scale = resolution / this.getResolution(z); var origin = this.getOrigin(z); var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_); var adjustX = reverseIntersectionPolicy ? 0.5 : 0; var adjustY = reverseIntersectionPolicy ? 0 : 0.5; var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX); var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY); var tileCoordX = scale * xFromOrigin / tileSize[0]; var tileCoordY = scale * yFromOrigin / tileSize[1]; if (reverseIntersectionPolicy) &#123; tileCoordX = Math.ceil(tileCoordX) - 1; tileCoordY = Math.ceil(tileCoordY) - 1; &#125; else &#123; tileCoordX = Math.floor(tileCoordX); tileCoordY = Math.floor(tileCoordY); &#125; return ol.tilecoord.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);&#125;; 二、各种瓦片加载的小结通过上述分析后，应该能较好的理解瓦片的坐标是如何计算的，当应用到不同的地图瓦片加载时就可以得心应手。以下通过不同的几种类型继续说明瓦片计算的方式： 1、TMS瓦片加载先看看TMS瓦片的规则，origin在左下角，X轴从左至右递增，Y轴从下往上递增（先计算左下角，然后计算右上角）。 而TileGrid设置origin为ol.extent.getBottomLeft(extent)后，规则也是从左下角到右上角，X轴从左至右递增，Y轴从下往上递增，与TMS规则是完全一致的，参考代码与参考效果如下： 1234567891011121314151617181920212223242526272829303132333435363738var resolutions = [];var tileSize = 256;var extent = [12665080.52765571, 2550703.6338763316, 12725465.780000998, 2601457.820657688]; //深圳地区var projection = new ol.proj.get(\"EPSG:3857\");var projectionExtent = projection.getExtent();for (var i = 0; i &lt; 19; i++) &#123; resolutions[i] = Math.pow(2, 18 - i);&#125; var tilegrid = new ol.tilegrid.TileGrid(&#123; origin: ol.extent.getBottomLeft(projectionExtent), resolutions: resolutions, extent: projectionExtent,//extent, tileSize: [256, 256],&#125;); var map = new ol.Map(&#123; target: \"map\", layers: [ // 调试瓦片 new ol.layer.Tile(&#123; source: new ol.source.TileDebug(&#123; projection: projection, tileGrid: tilegrid, tileSize: [256, 256], extent : projectionExtent, wrapX: false &#125;), &#125;) ], view: new ol.View(&#123; projection: projection, center: [12697184.079535482, 2563239.3065151004],//深圳 resolutions: resolutions, &#125;),&#125;);map.getView().setZoom(1); 假如上面代码中，我想只显示深圳地区的瓦片，其余的瓦片不显示，这种场景是很普遍的，那么代码调整如下： 123456789101112131415161718var tilegrid = new ol.tilegrid.TileGrid(&#123; origin: ol.extent.getBottomLeft(projectionExtent), //origin位置不能变！！！！！！ resolutions: resolutions, extent: extent,//projectionExtent //设置extent为深圳片区的extent； tileSize: [256, 256],&#125;);// ..................// 调试瓦片new ol.layer.Tile(&#123; source: new ol.source.TileDebug(&#123; projection: projection, tileGrid: tilegrid, extent: extent,//projectionExtent //设置extent为深圳片区的extent； wrapX: false &#125;),&#125;) 2、WMTS瓦片加载WMTS规则如下，origin在左上角，X轴从左至右递增，Y轴是从上往下递增（先计算左上角，然后计算右下角） 那么将tileGrid设置origin为ol.extent.getTopLeft(projectionExtent), 但是TileGrid始终都是先计算左下角的瓦片坐标，然后计算右上角的瓦片坐标，因此Y轴是相反的。那么修改Y轴坐标就可以得到正确值： 123456789101112131415161718192021222324var tilegrid = new ol.tilegrid.TileGrid(&#123; origin: ol.extent.getTopLeft(projectionExtent), // WMTS Origin在左上角，origin位置不能变； resolutions: resolutions, extent: extent, tileSize: [256, 256],&#125;); // 其余代码略.....new ol.layer.Tile(&#123; source: new ol.source.TileImage(&#123; projection: projection, tileGrid: tilegrid(), tileUrlFunction: function (tileCoord, pixelRatio, proj) &#123; if (!tileCoord) &#123; return \"\"; &#125; var z = tileCoord[0]; var x = tileCoord[1]; var y = -tileCoord[2] - 1; // y轴取反，-1目的是为了从0开始计数； return ''; // 自行设置URL ，请注意 WMTS中用TileRow标识Y，用TileCol表示X； &#125; &#125;),&#125;) 3、百度地图瓦片加载百度瓦片片规则如下：Origin在[0,0]，X轴从左至右递增，Y轴从下往上递增（从左下角到右上角）。 从百度的瓦片规则看出来，与TileGrid的规则是完全一致，将origin设置为[0,0]即可。参考代码如下：1234567891011121314151617181920212223242526 var tilegrid = new ol.tilegrid.TileGrid(&#123; origin: [0, 0], resolutions: resolutions, extent: extent,//projectionExtent, tileSize: [256, 256], &#125;);var tilesource = new ol.source.TileImage(&#123; projection: projection, tileGrid: tilegrid, tileUrlFunction: function (xyz, obj1, obj2) &#123; if (!xyz) &#123; return \"\"; &#125; var z = xyz[0]+ 11; // 从第11级开始加载；深圳地区； var x = xyz[1]; var y = xyz[2]; if (x &lt; 0) &#123; x = \"M\" + (-x); &#125; if (y &lt; 0) &#123; y = \"M\" + (-y); &#125; return \"http://online3.map.bdimg.com/tile/?qt=tile&amp;x=\" + x + \"&amp;y=\" + y + \"&amp;z=\" + z + \"&amp;styles=pl&amp;udt=20141119&amp;scaler=1\"; &#125; &#125;); 4、腾讯地图瓦片加载腾讯地图完全遵守TMS规则，地图投影坐标系采用Web Mercator投影，最小缩放级别为第4级。参考代码如下：123456789101112131415161718192021// QQ地图完全遵守TMS规则;var tileGrid = new ol.tilegrid.TileGrid(&#123; resolutions: resolutions3857, tileSize: [256, 256], extent: projection3857Extent, origin: ol.extent.getBottomLeft(projection3857Extent), // Origin左下角&#125;);var tilesource = new ol.source.TileImage(&#123; tileUrlFunction: function (xyz, obj1, obj2) &#123; if (!xyz) &#123; return \"\"; &#125; var z = xyz[0]; var x = xyz[1]; var y = xyz[2]; return \"http://rt1.map.gtimg.com/realtimerender?z=\" + z + \"&amp;x=\" + x + \"&amp;y=\" + y + \"&amp;type=vector&amp;style=0&amp;v=1.1.2\" &#125;, projection: projection3857, tileGrid : tileGrid&#125;);","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 动画","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch11/index.html","text":"动画在OpenLayers 3中，动画是随处可见的，比如平移地图时，地图移动会有惯性，停止移动后，还会继续沿着之前的方向移动一会。 比如下面这个地图具有回到原始点的功能，一个是有动画效果的，一个是没有动画效果的。 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); function backNoAnim() { map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); } function backWithAnim() { var pan = ol.animation.pan({ duration: 2000, source: map.getView().getCenter() }); map.beforeRender(pan); map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); } 先把地图移动到北京，再点击下方的两个按钮，感受一下带动画，和不带动画的差别，绝大多数人还是会喜欢带动画的。 无疑，动画具有很大的吸引力。 本章节将把你带入OpenLayers 3的动画世界，让你也能应用动画效果，做出漂亮的效果。 动画简单应用前面那个回到原点的动画，使用了OpenLayers 3内置的动画效果，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;!--增加两个按钮，一个演示不带动画，一个演示带动画--&gt;&lt;input type=\"button\" value=\"回到原点-不带动画\" onclick=\"backNoAnim()\"&gt;&lt;/input&gt;&lt;input type=\"button\" value=\"回到原点-带动画\" onclick=\"backWithAnim()\"&gt;&lt;/input&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 不带动画的实现 function backNoAnim() &#123; map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); &#125; // 带动画的实现 function backWithAnim() &#123; // 注意： 应用内置的动画，实现平移动画 var pan = ol.animation.pan(&#123; duration: 2000, source: map.getView().getCenter() &#125;); // 注意： 使用beforeRender来添加 map.beforeRender(pan); // 然后才是重新设置地图中心点到原来的位置 map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); &#125; &lt;/script&gt; 关键的代码始终在最后，结合注释，应该可以理解。 我们使用的内置动画是ol.animation.pan，用于平移动画，更详细的信息请参考官网API。 可以看到它是一个函数，返回一个ol.PreRenderFunction，添加到ol.Map，从而在渲染的时候使用，实现动画。 除了上面应用的动画之外，还有一些内置的动画，都在ol.animation里面，从官网API可以看到，包括： ol.animation.bounce: 来回弹。 ol.animation.pan: 平移。 ol.animation.rotate: 旋转。 ol.animation.zoom: 缩放。 这些动画都可以尝试，或许就有你需要的。 动画高阶应用虽然内置动画并不多，但是细心的同学已经发现了内置动画有个参数easing，这是一个强大的参数，因为可以让开发者自定义动画实现，从而实现动画效果的扩展。 其实已经内置了一些相关的实现，在ol.easing里面，涉及到一些常用的效果，包括： ol.easing.easeIn: 加速 ol.easing.easeOut: 减速 ol.easing.inAndOut: 先加速再减速 ol.easing.linear: 匀速 ol.easing.upAndDown: 和inAndOut类似 在前面的地图的基础上修改一下，让大家体验一下不同的动画的效果： easeIn easeOut inAndOut linear upAndDown var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); function backNoAnim() { map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); } function getEasing() { var typeSelect = document.getElementById('easing-type'); var easing = typeSelect.options[typeSelect.selectedIndex].text; if (easing === 'easeIn') { return ol.easing.easeIn; } else if (easing === 'easeOut') { return ol.easing.easeOut; } else if (easing === 'inAndOut') { return ol.easing.inAndOut; } else if (easing === 'linear') { return ol.easing.linear; } else if (easing === 'upAndDown') { return ol.easing.upAndDown; } } function backWithAnim() { var pan = ol.animation.pan({ duration: 2000, source: map.getView().getCenter(), easing: getEasing() }); map.beforeRender(pan); map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); } 尝试完所有的动画方式后，可以看一下其实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;!--添加动画效果选择项--&gt;&lt;select id = \"easing-type\"&gt; &lt;option&gt;easeIn&lt;/option&gt; &lt;option&gt;easeOut&lt;/option&gt; &lt;option&gt;inAndOut&lt;/option&gt; &lt;option&gt;linear&lt;/option&gt; &lt;option&gt;upAndDown&lt;/option&gt;&lt;/select&gt;&lt;input type=\"button\" value=\"回到原点\" onclick=\"backWithAnim()\"&gt;&lt;/input&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 根据选择项，返回对应的动画，供下面的backWithAnim函数使用 function getEasing() &#123; var typeSelect = document.getElementById('easing-type'); var easing = typeSelect.options[typeSelect.selectedIndex].text; if (easing === 'easeIn') &#123; return ol.easing.easeIn; &#125; else if (easing === 'easeOut') &#123; return ol.easing.easeOut; &#125; else if (easing === 'inAndOut') &#123; return ol.easing.inAndOut; &#125; else if (easing === 'linear') &#123; return ol.easing.linear; &#125; else if (easing === 'upAndDown') &#123; return ol.easing.upAndDown; &#125; &#125; function backWithAnim() &#123; var pan = ol.animation.pan(&#123; duration: 2000, source: map.getView().getCenter(), easing: getEasing() // 设置对应选择的动画 &#125;); map.beforeRender(pan); map.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); &#125; &lt;/script&gt; 通过上面这种方法，我们完全可以自定义动画函数，通过官网API文档可知，这些函数有一个参数t，范围在0-1之间，然后函数返回一个0-1之间的数。 结合动画业务来看，虽然官网没有说明参数表示什么意思，但是我们可以猜测它就是时间，返回的值应该目标达成比。 下面我们自己来实现一个sin曲线式的动画： var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // sin曲线动画 function sin(t) { // 使用sin曲线公式 return Math.sin(t * Math.PI / 2); } function backWithAnim2() { var pan = ol.animation.pan({ duration: 2000, source: map2.getView().getCenter(), easing: sin }); map2.beforeRender(pan); map2.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); } 速度一开始会快一点，然后慢下来， 对应的代码如下：12345678910111213141516171819202122232425262728293031323334&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;input type=\"button\" value=\"回到原点\" onclick=\"backWithAnim2();\"&gt;&lt;/input&gt;&lt;script type=\"text/javascript\"&gt; var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // sin曲线动画 function sin(t) &#123; // 使用sin曲线公式 return Math.sin(t * Math.PI / 2); &#125; function backWithAnim2() &#123; var pan = ol.animation.pan(&#123; duration: 2000, source: map2.getView().getCenter(), easing: sin // 应用sin曲线动画 &#125;); map2.beforeRender(pan); map2.getView().setCenter(ol.proj.transform([104, 30], 'EPSG:4326', 'EPSG:3857')); &#125; &lt;/script&gt; 利用postcompose事件做动画前面的内置动画，几乎都是和地图浏览相关的，很多时候我们有更多的动画需求，在此向大家介绍另一种可以做出动画的方式。 那就是利用ol.Map的postcompose事件，这个事件在地图渲染时都会触发，而我们只要改变地图上的某个feature或者layer或者其他任何东西，就会触发重新渲染。 如果利用这个原理，我们不断的改变feature的样式，就会触发postcompose，在这个事件的监听器里再改变feature的样式，就又会触发postcompose，从而一只循环下去，出现动画效果。 比如像下面这样： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); var circle = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }); circle.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 0, stroke: new ol.style.Stroke({ color: 'red', size: 1 }) }) })); layer.getSource().addFeature(circle); var radius = 0; map.on('postcompose', function(){ radius++; radius = radius % 20; circle.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: radius, stroke: new ol.style.Stroke({ color: 'red', size: 1 }) }) })); }) 地图中间的小圆圈，不断的重复变大动画，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); var circle = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;); circle.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 0, stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;)); layer.getSource().addFeature(circle); // 关键的地方在此：监听postcompose事件，在里面重新设置circle的样式 var radius = 0; map.on('postcompose', function()&#123; // 增大半径，最大20 radius++; radius = radius % 20; // 设置样式 circle.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: radius, stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;)); &#125;)&lt;/script&gt; 使用过Javascript做动画的同学可能会想，为什么弄的这么麻烦，直接用requestAnimationFrame不就行了？ 是的，我也这么认为，这个会比较简单，但如果你非要用OpenLayers 3的事件，也就可以照着上面的方式来实现动画了。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"一个简单的地图","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch02/index.html","text":"一个简单的地图在有了初步了解之后，从本节开始，我们将直接进入主题，体验一下使用OpenLayers 3做地图的难度，及地图的外观和功能： new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: ‘map’ }); 要显示上面这个地图，仅需要新建一个html文档，在其中编写如下代码即可： 123456789101112131415161718192021222324252627282930313233&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt; &lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"IE=edge,chrome=1\"&gt; &lt;meta content=always name=referrer&gt; &lt;title&gt;OpenLayers 3地图示例&lt;/title&gt; &lt;link href=\"../ol3.13.1/ol.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;script type=\"text/javascript\" src=\"../src/ol3.13.1/ol.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;script&gt; // 创建地图 new ol.Map(&#123; // 设置地图图层 layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], // 设置显示地图的视图 view: new ol.View(&#123; center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 &#125;), // 让id为map的div作为地图的容器 target: 'map' &#125;); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 要想使用OpenLayers 3开发地图，首先你需要引入了OpenLayers 3的js库文件ol3.js及样式文件ol3.css，参见代码中html头部。它们可以在github上下载到。 请注意，每一个版本，都有4个下载链接，如果你不需要研究源码和例子，只用下载第一个 v*-dist.zip，下载解压后，里面包含ol.css，ol.js，ol-debug.js这三个文件，在初学时，尽量使用ol-debug.js，如果发生错误，堆栈信息更为可读，便于排查问题。 如果需要学习和研究源码，可以下载后面的三个文件，但注意，需要自己编译生成ol.css，ol.js，ol-debug.js，切不可直接使用源码中的同名文件。 注意： 上面这个段代码注明html文件编码为utf-8，所以你新建的html文件本身编码需要保证为utf-8，不然会导致中文乱码。 紧接着就是使用OpenLayers 3的API创建地图，对应于&lt;script&gt;...&lt;/script&gt;代码块，如代码所见，7行代码就搞定了，是不是非常的简单？！至于代码的含义，可以暂时参照代码中的注释来理解。 看不懂也没有关系，接下来我们将详细的介绍它们。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 介绍","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch01/index.html","text":"OpenLayers 3 介绍OpenLayers 3简称ol3，它是一个开源的Web GIS引擎，使用了JavaScript、最新的HTML5技术及CSS技术，支持dom，canvas和webgl三种渲染方式。除了支持网页端，还支持移动端（目前移动端还不成熟，有待进一步完善）。在地图数据源方面，支持各种类型的瓦片地图，既支持在线的，也支持离线的。比如OSM, Bing, MapBox, Stamen, MapQuest等等；还支持各种矢量地图，比如GeoJSON，TopoJSON，KML，GML等等。随着OpenLayers 3的进一步发展，将支持更多的地图类型。 不兼容OpenLayers 2在OpenLayers 3之前，还有OpenLayers 2，虽然从名字上看是一个升级版本，但OpenLayers 3完全是重新设计，采用全新的架构，使用方式及API都不一样，只是在功能上完全实现OpenLayers 2已有的功能。为此，使用OpenLayers 3不必先学习OpenLayers 2。但使用过OpenLayers 2，并不等于直接就会用OpenLayers 3，仍然需要从零开始学习。 浏览器支持由于OpenLayers 3使用了HTML5技术，所以对各种浏览器的版本有所要求。IE浏览器最低也需要IE9才行，以下的IE浏览器可以考虑使用OpenLayers 2。其他浏览器的最低版本要求为Firefox 3.5，Chrome 3.0，Safari 3.0，Opera 10.5。如果要使用webgl渲染方式，则又需要参考各大浏览器的支持程度进行选择。 代码规范 OpenLayers 3采用面向对象的编程范式，类在API中随处可见，比如ol.Map，ol.View等等。如果你有面向对象的思维，将较为容易的理解API及使用。 OpenLayers 3采用包管理的方式管理代码，比如layer的包名为ol.layer，命名方式类似于JAVA的包名。这源于OpenLayers 3采用了Google的Closure库。 OpenLayers 3采用驼峰式(Camel-Case)命名，变量名采用小驼峰命名，类名使用大驼峰命名。 资源OpenLayers 3的官网是http://openlayers.org/，若记不住，请保存到收藏夹。在官网首页上，即可看到相关的介绍，文档，API，以及Examples链接。这些资料都跟随最新的版本实时更新，如果发现本教程有些内容和官方不一致，请以官网资料为准，可能由于版本更新导致的。 喜欢研究源码的开发者，请关注github https://github.com/openlayers/ol3。有能力者，可以考虑为OpenLayers 3提交PR和issue，不过在此之前请先阅读贡献文档","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3地图","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch03/index.html","text":"OpenLayers 3地图本章节将围绕前面那个简单的地图展开，从源码分析入手，逐步延伸到地图组成部分的分析，并学会借助API文档来帮助我们理解。 在此基础上，还提供了一些关于ol.Map类的应用实例，以帮助大家进一步的实践，为接下来更深入的学习和使用打下坚实的基础。 初步解析地图组成创建地图的代码如此简单，以致于让一部分初学者误认为在此基础上的深入开发也很简单，这是一个非常错误的理解。此时，最关键的第一步是先弄明白每一句代码的含义，理解他们是如何组织起来的。否则，在后续的学习和使用过程中，犹如瞎子摸象，会找不到问题的关键点而迷失方向。让我们再次回顾一下之前那个简单地图的代码： 123456789101112131415// 创建地图 new ol.Map(&#123; // 设置地图图层 layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], // 设置显示地图的视图 view: new ol.View(&#123; center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 &#125;), // 让id为map的div作为地图的容器 target: 'map' &#125;); 注意，其实上面这段代码就只有一条语句:1new ol.Map(&#123;...&#125;); 其他代码只是用于设置地图的构造参数。由此可以推测出ol.Map是最主要的地图类，创建地图就需要构造这么一个对象。接下来依次分析每一个参数部分的代码。 参数layers:1234layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], 从名字和具体的值可见这个地方可以设置多个layer，它是OpenLayers 3地图的组成结构单元，地图是由多个layer组成的，这种设计类似于Photoshop里面的图层，多个图层是可以叠加的，在最上面的会覆盖下面的，以此类推。在代码中我们添加了一个Open Street Map的地图layer。 参数view：1234view: new ol.View(&#123; center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 &#125;), 通过字面意思可以看出，它为地图定义显示窗口，对应ol.View类，可以自定义地图显示的中心点，缩放层级等。 参数target：1target: 'map' 指定地图在页面中具体哪个位置进行显示，为此要记住地图显示还是离不开使用dom来实现。虽然和地图业务没什么关系，但也必不可少，因为它是Web GIS，最基本的还是依赖于HTML。 通过上面的源码解读，我们可以发现OpenLayers 3地图主要是由layer和view组成，layer可以有多个，view只能有一个。 上图能明确看到的是layer，看不出view在哪儿，只知道地图显示中心确实在经度0，纬度0处。除此之外，还能看到左上角的放大缩小按钮，以及右下角的属性信息按钮。如果在地图上双击鼠标左键，或者按住鼠标左键拖动，可以看到地图也是会放大或者移动的。这些都是分析代码并没有看到的。很明显OpenLayers 3有很多默认行为，一个地图的完整构成，远不是只有view和layer就行了。 地图所有组成部分那么OpenLayers 3究竟由哪些部分组成？下面就将核心组成部分一一罗列出来： 地图(Map)，对应的类是ol.Map，之前已有接触。从代码上来看，它就像是一个空壳子，感觉没做什么实事，因为具体事务都由其他组成部分处理了。但没有它，整个地图的其他组成部分就不能有效协调，组织在一起。同时对于开发者而言，它就是第一个入口，我们必须要掌握。 视图(View)，对应的类是ol.View，之前已有接触，控制地图显示的中心位置，范围，层级等，此处不再过多介绍。关于其详细说明参见View。 图层(Layer)，OpenLayers 3有多种多样用于不同业务的图层，每一种图层在实现上都对应于一个类，放在包ol.layer下面，之前已接触过的ol.layer.Tile就是其中的一种。OpenLayers 3允许多个layer重叠在一起，相互之间互不干扰，是一种图形显示和管理的有效方式。应用这种方式能有效处理地图数据来源的多样性和复杂性问题。对开发者而言，它更多的表现为组织管理的类。 数据源(Source)，它是和图层一一对应的，OpenLayers 3也存在多种不同的数据源，每一种在实现上也对应于一个具体的类，它们都放在包ol.source下面，之前接触过的ol.source.OSM就是其中的一种。 毫无 疑问，它是整个地图背后真正的核心。 如果没有数据，那么渲染引擎将没有任何价值。在数据技术(Data Technology)大行其道的今天，GIS引擎将需要支持各式各样的数据来源。目前ol3也确实是这样做的，已支持多种多样在线或离线的数据源；可以是静态图或者瓦片图；也可以是栅格化的或者矢量的。如果你想在地图上加载某种格式的数据，或者某种服务提供的数据，都可以优先查看一下OpenLayers 3是否已经支持了。图层和数据源是密不可分的，详情可参见Source和Layer。 控件(Control)，它为用户提供了和地图交互的入口。 针对不同的用途，具有不同的控件。其实现类都放在包ol.control下面，在此之前还没有具体接触过，但我们在地图上看到的放大缩小按钮就是众多控件中的一种。控件具备相同的一个特性，就是一直保持在地图的某个固定位置，不会随着地图移动而移动，也不会随着地图放大缩小而变化，一直处于地图的最上层。关于控件更详细的说明参见Control。 交互(Interaction)，这是所有软件都具备的一个组成部分，直观地是看不见的，其实现类放在包ol.interaction下面，之前也没具体接触过，但其实是使用到了，如果没有它，我们就没有办法直接用鼠标控制地图放大、缩小、移动。这并不仅仅存在于GIS引擎中，它存在于任何产品中。任何优秀的产品必然有着良好的交互能力，即使没有任何GIS知识，也能体会到它的作用和重要性。 以上就是一个OpenLayer 3地图所有核心的组成部分， 他们有机的组合在一起，从而构成整个地图，实现了我们对地图的完整需要。 OpenLayer 3采用这样的模块化设计，不管是在实现上，还是对外提供API，都简化了整个系统。我们只要完整地了解每一个组成部分，就能游刃有余地运用它。在这些组成部分中，只有Layer和Source有直接的强联系，其他的组成部分，相互之间的联系很少。为此，在掌握某一部分后，就可以有效地处理这一部分的开发工作，从而不一定要掌握所有组成部分。 本教程的章节也是按照各个模块来分别介绍的，并不一定需要按照章节顺序进行学习。 看懂API或许你已经迫不及待的想开始学习第一个组成部分Map了，但在此之前，还是不得不先学会使用官网的API文档。因为API的重要性众人皆知，对于一个快速开发中的开源项目，更是如此，每一个小版本之间都可能有些许变化。所以在更新版本后，如果遇到API方法不存在或者功能不正确，则需要优先核对官网API文档。本着授之以鱼不如授之以渔的原则，学会看懂API文档是关键，而不是翻译API文档。。 API文档入口在浏览器中打开OpenLayers官网 http://openlayers.org/，下图箭头所指向的地方即为API文档链接： 点击进入即为整个API文档的首页，页面上方为工具栏，左边为搜索栏和列表，右边为OpenLayers 3组成部分的介绍，都是相关的类和一些简介。 上方工具栏中的Stable Only复选框选中后，API文档就只会显示功能已经稳定的类，参数，接口等信息。在查找新功能或新特性时，建议不要勾选。 右边页面显示了地图组成的介绍，Map、View、Layers列在第一排，第二排及第三排依次列出了其他的组成部分。有简单的介绍，及对应的包和类，可以通过这些资料加深对他们的认识。 查找左边的列表会根据搜索栏的内容进行过滤。大家可以尝试一下，在这里能搜索包名，类名，方法名和事件名。包名比如ol.layer，ol.source等，方法名比如setCenter，setZoom等，类名比如View，Map等，事件名比如`change:layers。但目前还不支持文档里面的内容的文本搜索。 API文档介绍此处以ol.Map类的API文档为例进行说明。在搜索栏输入ol.Map，很快下方列表中的内容就变了，排在中第一项的就是ol.Map类，点击它，右边页面内容就变成了它的说明文档。文档内容从上向下，共分为三部分： 类介绍，主要介绍该类用途，建议仔细阅读，这样才能根据具体业务找对需要的类。 构造参数、事件及继承关系，该内容的重要性无需多言，看不明白，就无法创建该类的对象。 类的所有方法，建议浏览一下，了解每个方法所实现的功能，在需要时，再详细查看对应的参数和使用方式。 请结合上面的内容快速浏览一下ol.Map的说明文档，感受一下，总的来说，OpenLayers 3的API文档是比较全面的，内容也挺详实(ol3的API文档是从代码的注释中通过工具提取生产的，所以时刻能保持更新，且完全符合JSDoc规范，文档和代码完全匹配)。 文档中类的介绍部分是否能看懂，因人而异，当了解的越多，就越容易看明白。因为它只是类的一些简要说明，谈不上详细，也没有对应的应用说明。有些类的用途需要结合到其他的知识才能更明白。在不是很明白的情况下，建议多结合类提供的方法的用途来一起理解。 类的构造参数采用的是JSDoc规范定义的，使用工具提取而出，生成了下面的参数文档，在此对其格式进行简要说明，参见下面图解： 页面右边的文件和行号标注都是可点击的，点击打开跳转到对应的源码，对于探究背后实现，或者分析Bug非常有用。然后是参数说明，很多对象的构造参数都是对象，以{key1:value1, key2:value2}这样的方式设置。这种方式有两方面的好处： 可以只设置需要的参数，或者增加自定义参数 易于为指定参数设置正确的值，避免值对应到错误的参数上。 需要注意的是参数类型Type的说明，使用符号|表示该参数可以赋予多种类型的值，对开发者是非常友好的，灵活强大。参数类型如果是容器，都会使用&lt;&gt;来表示。如果是OpenLayers 3自定义的类型，都是可以点击查看的。若为JavaScript的原生类型或DOM类型，则只给出类型名。对于各个参数的描述信息，就是一段文字，都比较详细。 除了参数之外，在OpenLayers 3中还大量使用了事件，用于解决实时通知的问题，这是典型的观察者模式。当对象改变时，能触发相应的操作。在API文档中，明确标注了各个类的事件，以及触发该事件的条件和时机。它们都列在Fires:这一栏，比如ol.Map就有很多事件，click、dbclick、singleclick、moveend等等。这些事件对于开发者来说非常重要，除了OpenLayers 3需要大量使用这些事件，很多应用开发也需要使用它们来实现一些关键功能。关于事件更详细的说明参见事件。 在事件说明之后，还有类继承的说明。Subclasses列出了当前类的所有子类；Extends列出了当前类的父类。不要小瞧这个说明，因为在面向对象编程范式中，所有能用父类的地方，都可以用子类。比如ol.Map的构造参数options可以设置layers属性，它的值是ol.layer.Base类型元素的集合，那么就可以用ol.layer.Base的子类ol.layer.Group或ol.layer.Layer，以此类推，也可以用这两个类的子类ol.layer.Image、ol.layer.Tile、ol.layer.Vector等。这样我们就知道具体哪些参数能用哪些类了。 最后就是这个类所有方法的说明了。方法的说明包含方法名，参数，以及方法功能描述。同类的说明差不多，为此不再累述。 最后，提醒一下，在遇到任何问题时，请优先查询API文档来排忧解惑。 结合API文档分析代码这次，有了API文档这个利器，必然会对代码有更深入的理解和认识。让我们再一次回顾之前那个简单的地图的代码： 123456789101112131415// 创建地图 new ol.Map(&#123; // 设置地图图层 layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], // 设置显示地图的视图 view: new ol.View(&#123; center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 &#125;), // 让id为map的div作为地图的容器 target: 'map' &#125;); 之前我们并不知道ol.Map类具体有什么构造参数，也不知道参数值可以设置什么类型的对象等等，现在就可以通过API文档查看。通过API文档可以看到，构造参数远不止上面代码中设置的这些参数，还存在很多其他的参数。这些参数在文档中注明是可以不设置的，OpenLayers3 会自动使用特定的默认值。通过这些参数，你是否已经发现它们其实就是地图的组成部分。为什么有些参数可以不设置而使用默认值，而有些参数就必须设置呢？请自行思考。 文档显示ol.Map的构造参数layers，可以是ol.Collection，也可以是Javascript数组，此处用了数组。我们统称为容器类型，包含的元素为ol.layer.Base类型。但代码里面创建了一个ol.layer.Tile类的实例，这样也行？通过API文档中的继承关系信息，我们可以了解到ol.layer.Tile继承于ol.layer.Layer，而ol.layer.Layer又继承于ol.layer.Base，所以这是可行的。 ，若对ol.layer.Tile不了解，请使用API文档，在此之前，我们也可以通过包名大致推断出它是一个layer，属于地图层的一种。官网API文档说明：它是一种应用瓦片图片作为地图源的地图层。构造函数的参数里包含一个必须设置值的属性：source，用于设置地图源，类型为ol.source.Tile，但是代码里使用的是ol.source.OSM，这个问题同上，请自行查询API文档解答吧。注意，Layer和Source就是这样绑定在一起的。有什么样的Layer，就需要什么样的Source，看起来是Layer决定Source，其实Layer是为Source服务的，还是之前说的那样，数据才是最重要的。所以应该是Source起决定作用，根据需要构造对应的Layer。为此在做开发时，应该优先考虑需要什么样的Source。这个也可以通过API文档来查找，搜索ol.source即可查看到现有哪些不同类型的source，在结果中逐个查看，直到找到需要的source类。假设找到了ol.source.Test，那么要找layer就简单了，一般情况下，会有ol.layer.Test。 如果没有，请查找ol.source.Test的父类对应的layer，以此类推。 参数View是一个必须设置的属性，对应于ol.View类，通过官网API了解详细信息，顺便详细看看它的构造参数中的center和zoom表示什么？View至关重要，后续将更深入的了解。 认真查看API文档，可以发现一些你意想不到的东西，从而有所启发，或学到新知识，或排忧解难，所以请重视API文档。至此，你应该对上面的代码有了非常深入的理解了，此时不妨试试修改一些参数的值，查看地图有什么变化。 ol.Map的应用到此，已经学习了足够多的知识，对ol.Map也比较熟悉了，如果遇到问题，也能从API文档中得到帮助，是时候动动手练习一下了。这之后就给出一些简单的应用，有兴趣的可以看看，没兴趣的可以直接跳过，进入下一章节。 定制地图logoOpenLayers 3作为一个引擎，供开发者二次开发来发布产品，必然需要重新设置logo，具体怎么做？通过ol.Map的API文档发现它的构造参数里面logo的设置，简单动动手就能做出下面这样带自定义logo的地图，注意右下角的猴子： new ol.Map({ controls: ol.control.defaults({ attributionOptions: ({ collapsible: false }) }), // logo: false, // 不显示logo // logo: 'face_monkey.png', // 用一个图片 face_monkey.png 作为logo logo: {src: '../img/face_monkey.png', href: 'http://www.openstreetmap.org/'}, // 点击能跳转到对应页面 layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: 'map' }); 因为今年是猴年，所以就用了它，当然你也可以换成任何其他想要的logo，代码如下： 123456789101112131415161718192021&lt;div id=\"map\" style=\"width: 100%, height: 400px\"&gt;&lt;/div&gt;&lt;script&gt; new ol.Map(&#123; controls: ol.control.defaults(&#123; attributionOptions: (&#123; collapsible: false &#125;) &#125;), // logo: false, // 不显示logo // logo: 'face_monkey.png', // 用一个图片 face_monkey.png 作为logo logo: &#123;src: '../img/face_monkey.png', href: 'http://www.openstreetmap.org/'&#125;, // 点击能跳转到对应页面 layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map' &#125;);&lt;/script&gt; 注意看代码中设置logo参数的注释，演示了最复杂的情况，注释掉的代码是一些简单的用法。可自行尝试换成它们有什么效果。 除了logo参数之外，我们还设置了controls，算是这个例子夹带的私货，其大致的作用，从官网API文档可以了解到，是设置地图控件的。有什么作用？注意对比现在的地图和之前的地图的右下角，一个是i，一个是展开的一串信息。 单页面多地图在某些业务中，可能需要在一个页面中加载多个地图，用于对比，或者多个业务方面的同时展示。那么OpenLayers 3能否做到单页面多地图互不干扰呢？ 地图1地图2 // 创建第一个地图 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: ‘map1’ }); // 创建第二个地图 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: ‘map2’ });试试两个地图都操作一下，确认相互之间是否有影响？对应的代码非常简单，无非就是数量多了一个，如下：1234567891011121314151617181920212223242526272829&lt;p&gt;地图1&lt;/p&gt;&lt;div id=\"map1\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;p&gt;地图2&lt;/p&gt;&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // 创建第一个地图 new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map1' &#125;); // 创建第二个地图 new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map2' &#125;);&lt;/script&gt;这段代码真没有什么需要解释的了。# 地图联动OpenLayers 3采用了MVC模型，V对应的就是View，这种设计模型有什么好处？我们还是直接看下面这两个地图： 地图1地图2 // 创建一个视图 var view = new ol.View({ center: [0, 0], zoom: 2 }); // 创建第一个地图 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: view, target: ‘map1’ }); // 创建第二个地图 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: view, target: ‘map2’ });拖动地图1的同时，看看地图2有什么变化，是不是很神奇，为什么呢？1234567891011121314151617181920212223242526272829&lt;p&gt;地图1&lt;/p&gt;&lt;div id=\"map1\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;p&gt;地图2&lt;/p&gt;&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script&gt; // 创建一个视图 var view = new ol.View(&#123; center: [0, 0], zoom: 2 &#125;); // 创建第一个地图 new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: view, target: 'map1' &#125;); // 创建第二个地图 new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: view, target: 'map2' &#125;);&lt;/script&gt;代码只有一点不同，即两个ol.Map使用了同一个view，就是这么神奇。# 动态交换地图在创建地图时，我们可以指定对应的地图容器，其实在创建完成之后，我们还可以动态设置不同的地图容器，从而可以让地图不断的变换位置，比如交换两个地图： 地图1 地图2 // 创建第一个地图 var map1 = new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: 'map1' }); // 创建第二个地图 var map2 = new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ center: [0, 0], zoom: 2 }), target: 'map2' }); function swapMap() { // 改变两个地图的容器 map1.setTarget('map2'); map2.setTarget('map1'); } 为了让两个地图有所差别，你可以先放大第一个地图，然后点击调换地图按钮，看一下效果。要实现这个功能，其实只需要使用setTarget方法即可： 123456789101112131415161718192021222324252627282930313233343536&lt;p&gt;地图1&lt;/p&gt;&lt;div id=\"map1\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;p&gt;地图2&lt;/p&gt;&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;input type=\"button\" onClick=\"swapMap();\" value=\"调换地图\" /&gt;&lt;script&gt; // 创建第一个地图 var map1 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map1' &#125;); // 创建第二个地图 var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; center: [0, 0], zoom: 2 &#125;), target: 'map2' &#125;); function swapMap() &#123; // 改变两个地图的容器 map1.setTarget('map2'); map2.setTarget('map1'); &#125;&lt;/script&gt; 其实很多时候，只需要多留意一下API文档里面的方法，了解功能，就可能实现意想不到效果。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 内置的地图控件","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch10/index.html","text":"Control 在OpenLayers 3中，地图控件指的是下图标注的这些，包括缩放按钮，标尺，版权说明，指北针等等。 他们不会随着地图的移动而移动，一直处于一个固定的位置。 在实现上，并不是在画布上绘制的，而是使用传统的HTML元素来实现的，便于同地图分离，也便于界面实现。 在本章节中，将先概览OpenLayers 3中已有的地图控件，对其实现进行分析，在此基础上进一步修改其样式，从而定义自己的控件。 控件概览OpenLayers 3目前内置的地图控件类都在包ol.control下面，依次有： ol.control.Attribution: 右下角的地图信息控件 ol.control.FullScreen: 全屏控件 ol.control.MousePosition: 鼠标位置控件 ol.control.OverviewMap: 鸟瞰图控件 ol.control.Rotate: 指北针控件 ol.control.ScaleLine: 比例尺控件 ol.control.Zoom: 缩放按钮控件 ol.control.ZoomSlider: 缩放滚动条控件 ol.control.ZoomToExtent: 放大到设定区域控件 每一个类都有一些设置参数，可对照官网API的文档来了解其对应的功能。 默认情况下，在地图上是不会显示这么多地图控件的，只会应用ol.control.defaults()这个函数返回的地图控件，默认包含了ol.control.Zoom，ol.control.Rotate和ol.control.Attribution这个控件。 其使用方式同ol.interaction.defaults()很像，同样可以设置一些参数来控制控件的一些功能，从而实现定制化需求。 比如下面这个地图上的控件稍微的同默认情况下的控件有点不一样，因为控件都不存在了。 var map = new ol.Map({ controls: ol.control.defaults({ attribution: false, rotate: false, zoom: false }), layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 代码如下：1234567891011121314151617181920212223242526&lt;head&gt; &lt;link href=\"../src/ol3.13.1/ol.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;script type=\"text/javascript\" src=\"../src/ol3.13.1/ol.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; // 设置地图控件，默认的三个控件都不显示 controls: ol.control.defaults(&#123; attribution: false, rotate: false, zoom: false &#125;), layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; 当然，上面这个代码有更简洁的写法: controls: []，上面只是演示ol.control.defaults方法的使用而已。 如果需要把所有控件都显示出来，那么可以这样： var map2 = new ol.Map({ controls: ol.control.defaults().extend([ new ol.control.FullScreen(), new ol.control.MousePosition(), new ol.control.OverviewMap(), new ol.control.ScaleLine(), new ol.control.ZoomSlider(), new ol.control.ZoomToExtent() ]), layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 有些控件重叠在一起，得仔细分辨。 代码如下： 12345678910111213141516171819202122232425&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map2 = new ol.Map(&#123; // 在默认控件的基础上，再加上其他内置的控件 controls: ol.control.defaults().extend([ new ol.control.FullScreen(), new ol.control.MousePosition(), new ol.control.OverviewMap(), new ol.control.ScaleLine(), new ol.control.ZoomSlider(), new ol.control.ZoomToExtent() ]), layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; 下图是一个界面控件和类的对照关系图： 每一个控件都有相应的参数设置，如果具体到某一个控件使用时，不能满足需求，可以先参照官网API说明，进行相应使用。 探究控件原理在介绍后续的知识之前，先探究一下控件是如何做成的。 在chrome中打开一个最简单的地图例子，打开开发者工具面板，用工具栏最左边的元素选择器选择地图左上方的放大按钮，可以看到类似如下的界面： 上图可以看到放大按钮完整的dom结构图，从而一窥究竟，按钮原来就是简单的HTML的元素，结合css的效果做出来的，可以看到放大按钮的css class为ol-zoom-in，紧接着的就是缩小按钮的节点，其css class为ol-zoom-out，他们的父节点也有对应的css class： ol-zoom。 我们可以在ol.css文件中找到这些class的定义，设置了相应的样式。 控件ui的原理是清楚了，那么对应的控件要响应一些鼠标或者按键操作，应该也就是添加响应的事件监听器就可以了。 对于具体怎么做的，我们可以从控件ol.control.Zoom的部分源码来分析： 123456789101112131415161718192021222324252627282930// 设定放大缩小按钮的提示信息 var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in'; var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out'; // 创建放大按钮的dom节点 var inElement = goog.dom.createDom('BUTTON', &#123; 'class': className + '-in', 'type' : 'button', 'title': zoomInTipLabel &#125;, zoomInLabel); // 并绑定鼠标点击事件的处理函数 handleClick_ ol.events.listen(inElement, ol.events.EventType.CLICK, goog.partial( ol.control.Zoom.prototype.handleClick_, delta), this); ...... // 函数定义如下 /** * @param &#123;number&#125; delta Zoom delta. * @param &#123;Event&#125; event The event to handle * @private */ol.control.Zoom.prototype.handleClick_ = function(delta, event) &#123; event.preventDefault(); // 阻止事件传递到下面的map this.zoomByDelta_(delta); // 调用具体的方法进行放大&#125;; 这个过程和我们平时的在界面上添加一个节点，再绑定事件处理函数，并没有什么差别，其他类似的控件也是一样的原理。这对我们来说，想改变ui样式，是非常容易的事，甚至可以改变它的默认行为。 控件美颜在知道原理后，想对控件美颜就是一件非常容易的事，大致有下面两种方式： 自定义CSS样式知道控件的实现原理后，美颜就变得非常简单了，找到对应的class，设置css样式，就轻松搞定，这完全就是css范畴的内容了，比如你可以做到下面这样： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 代码只涉及css代码，如下：1234.ol-zoom .ol-zoom-in &#123; background-color: #0000ff; color: #ff0000;&#125; 这段代码可以放在单独的css文件里面，也可以直接加载&lt;head&gt;&lt;/head&gt;里面，但必须是在ol.css引入之后加，这样才能覆盖ol3默认的css样式。 最简单粗暴的，莫过于直接在ol.css里面修改，但这样侵入性太强，不利于OpenLayers 3的版本升级，升级一次，就得自己修改一次。 所以不推荐。 其他控件的css样式修改同上，此处不再累述，请自行修改验证。 JavaScript修改在前端除了css之外，还可以用强大的javascript代码进行修改，比如像下面这样，把最大化按钮的图标改变一下： new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); $('#map2 .ol-zoom-in').html(''); 代码如下：12345678910111213141516171819&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 设置放大按钮符号，下面这个代码需要引入jquery，或者zepto库 $('#map2 .ol-zoom-in').html('&lt;&gt;');&lt;/script&gt; 使用javascript代码势必能更进一步定制各种控件。 自定义控件有了前面的基础介绍，自定义控件就变得相对简单了，共分为两个步骤，第一步是构建界面，第二步是用代码实现功能。 下面自定义了一个分享当前地图的功能： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); var viewport = map.getViewport(); $(viewport).append('分享地图'); document.getElementById('share').onclick = function() { alert('分享当前地图给朋友'); } 对应的代码如下： 12345678910111213141516171819202122232425&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在viewport节点下添加一个分享按钮 var viewport = map.getViewport(); $(viewport).append('&lt;div id=\"share\" class=\"share\"&gt;分享地图&lt;/div&gt;'); // 监听按钮点击事件，执行相关操作 document.getElementById('share').onclick = function() &#123; alert('分享当前地图给朋友'); &#125;&lt;/script&gt; 结合注释理解代码，对于分享按钮的外观都是由css来定义：123456789101112.share &#123; position: absolute; top: 10px; right: 10px; border: 1px; border-color: #333; background-color: #339999; color: #fff; box-shadow: 0px 0px 2px #666; cursor: pointer; padding: 0 4px 0 4px;&#125; 由此可见，自定义控件也是一件非常简单的事。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 LOD与分辨率","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch06/index.html","text":"LOD与分辨率LOD是Levels of Detail的简写，用于根据当前的环境，渲染不同的图像，用于降低非重要的细节度，从而提高渲染效率，在电子游戏中经常运用，对于需要显示全球地图的GIS系统而言，更需要应用这项技术。在万能瓦片地图加载秘籍中，有简单的说明。 在不同的细节层次下，自然分辨率就可能不一样，这两者是紧密结合在一起的。 对于图形显示系统而言，分辨率作为屏幕坐标和世界坐标之间计算的纽带，其作用是非常重要的。 本章节将以实例的方式深入浅出的讲解这两个重要的概念，及在OpenLayers 3中的应用。 LOD原理在详细讲解之前，假设给你两张A4纸，在其中一张纸上把你家整个绘制上去，在另一张纸上只把你睡的房间绘制上去。如果别人想看你家，你会给哪一张纸？如果想看你睡的房间，你会给哪一张纸？ 相信你不会给错，LOD就是这种根据不同需要，采用不同图的技术方案。在地图应用中，最直观的体验，就是地图放大缩小。当地图放大后，能看到更详细的地理信息，比如街道，商店等等。当地图缩小再缩小，原来能看到的街道，商店就看不见了，当能看到更大的区域，我们的屏幕就相当于是A4纸，大小不变。 LOD这个技术方案非常棒，非常符合我们的自然习惯，所以在很多图形系统中都使用了这项技术。在GIS系统中，不断放大，就能看到更多地图细节，了解更加详细的信息。对于GIS引擎的开发者而言，需要实现这项技术，当发现用户放大地图时，就立马使用更有细节的地图图片，替换现在显示的地图图片。 现在问题来了：意思是说对于同一个地点而言，需要有很多张呈现不同细节程度的图片？是的，你没有猜错，虽然在使用地图的过程中，感觉放大缩小地图是浑然一体的，但其实就在你眼皮下发生了图片替换。 不同层级使用具有不同细节的地图图片，这就需要为每一个层级准备图片，如果使用离线工具下载瓦片地图，会看到下载的图片是按照层级Z进行存储的。开发者不用担心数据源的处理，只需要知道这个原理就可以了。 为了便于理解GIS系统中不同层级，使用不同的图片，下面使用google在线瓦片地图进行说明。 最小层级0情况下，只用了一张256*256像素的图片表示整个地球平面： 稍大一个层级1情况下，用了四张256*256像素的图片来表示整个地球： 对照一下，是否更加的明白了LOD原理及在GIS中的应用？ 瓦片计算不同环境条件下，加载具有不同细节的图片资源，可以提高效率，但这并不是终点。 瓦片技术可以更进一步提高效率。 其原理是将一张大图片切割成很多张小图片，按照呈现需要，加载其中的几张小图片即可。 为什么这样就能提高效率？因为屏幕显示窗口的大小是固定，比如屏幕分辨率是800*600，或者1024*768，又或者是1920*800等等。如果屏幕分辨率是800*600，一张大图是9000*9000，那么同一时间，你只能看到这张图片的十分之一。 但是在不切片的情况下，你却必须要加载整个地图。 如果是在本地浏览还好，假如是发布在网络上，则网络传输和渲染，都将耗时。如果我们按照500*500大小进行切片，我们则只需要加载4张500*500的小图片就可以了。 对于WebGIS而言，需要在网络上发布，同时需要显示整个地球，自然需要使用瓦片技术。 切片方式如果对整个地球图片进行切片，需要考虑的是整个地球图片大小，以及切片规则，切片大小。 对于WebGIS而言，在线地图几乎都采用墨卡托投影坐标系(Mercator)，对应的地图投影到平面上就是一个正方形。 为了方便使用，切片时大多按照正方形的方式来进行切片，比如切片大小为256*256。一个1024*1024的地图，就可以切成4张小的瓦片。 同时，瓦片大小几乎都是256*256，有一些则会增加到512*512。 LOD会使得不同层级下的全球地图大小不一致，结合瓦片技术一起，就出现了金字塔瓦片。 参见万能瓦片地图加载秘籍里面的图。 在WebGIS中，上一层级的一张瓦片，在更大一层级中，会用4张瓦片来表示，依次类推，比如上一节中看到的Google在线瓦片地图的第0级和第1级的瓦片地图。 这样做可以维持正方形的投影方式不变，同时按照2的幂次方放大，计算效率非常高。 计算通过上面切片的介绍，我们可以对每一层级瓦片的数量进行简单的计算。 层级0的瓦片数是$$1=2^02^0$$， 层级1的瓦片数是$$4=2^12^1$$，层级n的瓦片数是$$2^n*2^n$$。 这个地方计算的是所有瓦片数，因为是一个正方形，所以是边长的平方，如只计算x轴或者y轴一边的瓦片数，就是$$2^n$$个。 瓦片坐标任意一个层级的地图，切成多个瓦片后，我们需要给瓦片编号，才能通过编号找到瓦片。这个问题在这就涉及到坐标系，在万能瓦片地图加载秘籍里我们提到过，不同的在线地图服务商，可能定义不一样的瓦片坐标系，坐标系不一样，那么对应的同一个位置的瓦片的坐标也会不一样。 需要引起重视。 在OpenLayers 3提供了一个用于调试瓦片的source: ol.source.TileDebug。可以清晰的看到每一个瓦片的坐标： var osmSource = new ol.source.OSM(); var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: osmSource }), new ol.layer.Tile({ source: new ol.source.TileDebug({ projection: 'EPSG:3857', tileGrid: osmSource.getTileGrid() }) }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 代码如下： 12345678910111213141516171819202122232425&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var osmSource = new ol.source.OSM(); var map = new ol.Map(&#123; layers: [ // 加载Open Street Map地图 new ol.layer.Tile(&#123; source: osmSource &#125;), // 添加一个显示Open Street Map地图瓦片网格的图层 new ol.layer.Tile(&#123; source: new ol.source.TileDebug(&#123; projection: 'EPSG:3857', tileGrid: osmSource.getTileGrid() &#125;) &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;)&#125;);&lt;/script&gt; 首先从上图可以看到地图上多了网格，每一个网格对应的就是一个瓦片。 其次网格中有三个数字，这些数字就表示当前瓦片的坐标，第一个数字是层级z，第二个数字是表示经度方向上的x，第三个数字是表示维度方向上的y。 同样的，可以采用上面的方式来看看在万能瓦片地图加载秘籍中提到的各种瓦片地图的瓦片坐标。 分辨率前面简单提到过，分辨率是屏幕坐标和世界坐标的纽带，通过它，才能知道你在屏幕上用鼠标点击的位置对应于世界地图具体的经纬度位置。 当然你不用自己来做这个计算，OpenLayers 3的ol.Map已提供了对应的方法getCoordinateFromPixel来帮助你实现坐标转换。 你可能经常使用这个函数，但却不知道背后是怎样的一个原理，本小节将理清其中的来龙去脉。 上一节说到了每一个层级，会使用不同的瓦片数来表示整个地球，那么无论是哪一个层级，所表示的实际地理空间范围都是一致的。但使用的瓦片个数却是不一样的，以Google在线地图为例，层级0使用了一个瓦片，层级1使用了4个瓦片。 通过计算可以知道层级0整个地球图像为$$256256$$像素大小，层级1整个地球图像为$$512512$$像素大小。 层级0和层级1表示的地球范围都是一样的经度[-180, 180]，纬度[-90, 90]。 在层级0的时候，一个像素就表示$$\\frac{360}{256} = 1.40625$$这么长的经度范围，$$\\frac{180}{256}=0.703125$$这么长的纬度范围。 而这两个数字就是分辨率了，即一个像素所表达的范围是多少，这个范围可能是度，可能是米，或者其他单位，根据具体的情况而定。 墨卡托投影坐标系下的分辨率我们知道，在WebGis中使用的在线瓦片地图是采用的墨卡托(Mercator)投影坐标系，经过投影后，整个地球是一个正方形，所能表示的地球范围为经度[-180, 180]，纬度[-85, 85]，单位为度。 对应的墨卡托坐标系的范围x[-20037508.3427892, 20037508.3427892]，范围y同样是[-20037508.3427892, 20037508.3427892]，单位为m。 或许你会好奇这个范围是怎么计算而来的，如果详细了解过它的定义，应该知道墨卡托只是简单的把地球球面剖开拉伸为一个正方形而来，由于南北极两端采用这种拉伸会严重变形，并且南北极在使用过程中很少用到，所以干脆就只投影了[-85, 85]纬度范围的地球。 而展开时，因为纬度范围有缩减，所以肯定只能以经度来展开，即在经度-180度的地方从上到下剖开地球，然后按照赤道方向来展开成一张平面，那么这个平面的长，就等于以地球赤道半径按照圆来计算的周长。 近似的按照6378137米为半径来计算，那么整个赤道周长的一半，即为 $$\\pir=3.14159266378137=20037508.0009862$$ 以上就是墨卡托投影坐标系范围的完整的计算过程，墨卡托也有很多变形，会有细微的不同，OpenLayers 3默认使用的是EPSG:3857，对于该坐标系的详细定义，可以参见epsg.io 3867。 有了范围之后，要想计算分辨率，按照上面的计算过程就非常简单了，还是以Google在线瓦片地图为例，x方向上的分辨率计算公式可以归纳为： $$ resolution = \\frac{rangeX}{256*2^{level}}$$ rangeX表示x方向上整个范围，比如 $$20037508.3427892 - (-20037508.3427892)$$，256表示的一个瓦片的宽度，单位为像素，$$2^{level}$$表示的在层级level下，x方向上的瓦片个数。 那么分母计算出来的结果就是在层级level下，整个地图在x方向上的宽度，单位为像素。 那么整个公式计算出来就是在x方向上一个像素所能代表的实际地理范围，即分辨率。 OpenLayers默认使用的分辨率 当前层级：分辨率： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); map.getView().on('change:resolution', function(){ document.getElementById('zoom').innerHTML = this.getZoom() + '，'; document.getElementById('resolution').innerHTML = this.getResolution(); }) document.getElementById('zoom').innerHTML = map.getView().getZoom() + '，'; document.getElementById('resolution').innerHTML = + map.getView().getResolution(); 代码如下：1234567891011121314151617181920212223242526&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;div&gt;&lt;span&gt;当前层级：&lt;/span&gt;&lt;span id=\"zoom\"&gt;&lt;/span&gt;&lt;span&gt;分辨率：&lt;/span&gt;&lt;span id=\"resolution\"&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 监听层级变化，输出当前层级和分辨率 map.getView().on('change:resolution', function()&#123; document.getElementById('zoom').innerHTML = this.getZoom() + '，'; document.getElementById('resolution').innerHTML = this.getResolution(); &#125;) document.getElementById('zoom').innerHTML = map.getView().getZoom() + '，'; document.getElementById('resolution').innerHTML = + map.getView().getResolution();&lt;/script&gt; 缩放上面的地图，从层级0开始，用前面介绍的公式和当前地图显示的分辨率进行比较，你会发现OpenLayers默认采用的分辨率和Google在线瓦片地图一样。 注意事项为什么我们上面一直以Google在线瓦片地图举例说明？ 因为不同的在线瓦片地图可能采用不一样的分辨率，比如百度在线瓦片地图。 所以在使用在线瓦片地图或者自己制作的瓦片地图时，都需要知道使用的分辨率是多少。 如若不然，可能也会出现位置偏移。 自定义瓦片地图及加载","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 事件","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch08/index.html","text":"事件事件让很多业务的东西串联在一起，在前端中起着非常重要的作用，比如鼠标点击，移动事件。但其应用远不仅如此，现实生活中就存在很多大大小小的事件。 在OpenLayers 3中，同样存在非常多的事件，比如鼠标左键单击，双击等等。 同时还有一些用于各个模块之间进行协作使用的事件，比如ol.Map的postrender和propertychange事件。 通过这些事件，OpenLayers 3的功能模块协作一致，同样地，也可以让我们自己二次开发的功能模块运作起来。 同时，根据需要，我们还可以在系统中新增自定义事件，使得我们的开发使用方式同OpenLayers 3更加的一致。在本章节将详细介绍OpenLayers 3中的各种事件，及相关应用。 一个简单的事件应用在深入分析和理解之前，我们还是以简单的一个例子入手，来学习一下如何使用OpenLayers 3中的事件来做一个简单的事，从而熟悉整个流程。 用鼠标点击下面这个地图，将弹出一个对话框，显示点击位置的经纬度： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: ‘map’, view: new ol.View({ center: ol.proj.transform( [104, 30], ‘EPSG:4326’, ‘EPSG:3857’), zoom: 10 }) }); map.on(‘singleclick’, function(event){ alert(ol.proj.transform(map.getEventCoordinate(event), ‘EPSG:3857’, ‘EPSG:4326’)); })代码如下：12345678910111213141516171819202122&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 监听singleclick事件 map.on('singleclick', function(event)&#123; // 通过getEventCoordinate方法获取地理位置，再转换为wgs84坐标，并弹出对话框显示 alert(ol.proj.transform(map.getEventCoordinate(event), 'EPSG:3857', 'EPSG:4326')); &#125;)&lt;/script&gt;代码很简单，但需要注意的是，任意的事件应用，必然会有三个步骤： 找准事件发送者，比如上面这个例子，map就是事件发送者。 如何找到它呢？ 一般都是要交互的对象。 找准事件名称，比如上面例子中的singleclick，切忌不要随便想象，或者按照惯例来写名称，初次使用，请一定参照API文档，不然后果自负。 如何参看一个类有什么事件？ 请参见看懂API。 编写事件响应函数，在OpenLayers中，事件发送者都会有一个名字为on的函数，调用这个函数，就能监听指定的事件，响应函数listener具有一个参数event，这个event类就对应于API文档中事件名称后边括号里的类。这三个步骤缺一不可，如果使用过jquery监听事件，应该对此比较熟悉。 除此之外，关于OpenLayers 3中的事件应用，还有下面两点需要说明： 几乎OpenLayers 3中所有的类，都能监听事件和触发事件，因为它们都继承于类ol.Observable，这个类甚至是ol.Object的父类。 如此可见，OpenLayers在整个引擎中，是多么的依赖于事件通信。* 而OpenLayers 3的整个事件机制，又是基于Google的Closure Library。所以如果你对这个库熟悉，那么对OpenLayers 3提供的事件机制会比较熟悉。如果仅限于直接使用OpenLayers 3中的事件，就没有必要深入源码去探个究竟，只要遵照约定对事件进行应用就好。# 注销事件响应上一节的示例仅仅演示了如何监听一个事件，并响应处理。 但如果之后又不需要再响应该事件了，要怎么办。 比如有一个引导用户使用的需求，用户第一次点击地图的时候，需要弹出一个使用说明，之后点击地图就不用再弹出这个使用说明了。 那我们有哪些方式可以做到这一点呢？ 尝试点击一下下面这个地图，之后再点击一次试试： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: ‘map’, view: new ol.View({ center: ol.proj.transform( [104, 30], ‘EPSG:4326’, ‘EPSG:3857’), zoom: 10 }) }); var key = map.on(‘singleclick’, function(event){ alert(‘大家好，我是淡叔，这是一个演示如何取消事件监听的应用，之后再点击地图时，你将不会再看到这个说明。’); map.unByKey(key); })第二次点击地图后，是否就不会再弹出提示信息了？ 其实代码很简单：12345678910111213141516171819202122&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); var key = map.on('singleclick', function(event)&#123; alert('大家好，我是淡叔，这是一个演示如何取消事件监听的应用，之后再点击地图时，你将不会再看到这个说明。'); // 下面这行代码就是取消事件监听 map.unByKey(key); &#125;)&lt;/script&gt;除了上面这个方式可以注销事件监听之外，还可以用下面这样的方式：123456789101112131415161718192021222324&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 创建事件监听器 var singleclickListener = function(event)&#123; alert('大家好，我是淡叔，这是一个演示如何取消事件监听的应用，之后再点击地图时，你将不会再看到这个说明。'); // 在响应一次后，注销掉该监听器 map.un('singleclick', singleclickListener); &#125;; map.on('singleclick', singleclickListener);&lt;/script&gt;针对这个应用，还可以按照下面这样来实现：123456789101112131415161718192021&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 使用once函数，只会响应一次事件，之后自动注销事件监听 map.once('singleclick', function(event)&#123; alert('大家好，我是淡叔，这是一个演示如何取消事件监听的应用，之后再点击地图时，你将不会再看到这个说明。'); &#125;)&lt;/script&gt;到此，OpenLayers 3的事件应用基本介绍完毕，后续将介绍OpenLayers 3常用事件。# 常用事件几乎OpenLayers主要的类都会派发相关的事件，虽然事件很多，但日常使用的事件大致分为下面几类。## 常用鼠标事件### 地图鼠标左键单击事件对应的类为ol.Map，事件名为singleclick。### 地图鼠标左键双击事件对应的类为ol.Map，事件名为dblclick。### 地图鼠标点击事件对应的类为ol.Map，事件名为click。### 地图鼠标移动事件对应的类为ol.Map，事件名为pointermove。### 地图鼠标拖拽事件对应的类为ol.Map，事件名为pointerdrag。### 地图移动事件对应的类为ol.Map，事件名为moveend。可以通过下面这个地图来尝试一下鼠标事件： 触发事件提示信息 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: ‘map’, view: new ol.View({ center: ol.proj.transform( [104, 30], ‘EPSG:4326’, ‘EPSG:3857’), zoom: 10 }) }); map.on(‘singleclick’, function(event){ document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的单击事件：singleclick’; }); map.on(‘dblclick’, function(event){ document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的双击事件：dblclick’; }); map.on(‘click’, function(event){ document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的点击事件：click’; }); // map.on(‘pointermove’, function(event){ // document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的鼠标移动事件：pointermove’; // }); map.on(‘pointerdrag’, function(event){ document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的拖拽事件：pointerdrag’; }); map.on(‘moveend’, function(event){ document.getElementById(‘info’).innerHTML = ‘触发了ol.Map的地图移动事件：moveend’; });注意在singleclick和dblclick响应之前，都会触发click事件，在选择事件时，需要谨慎考虑。 同时发现moveend事件在地图缩放的时候，也会触发。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"info\" style=\"background-color: #999;\"&gt;触发事件提示信息&lt;/div&gt;&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 响应单击事件 map.on('singleclick', function(event)&#123; document.getElementById('info').innerHTML = '触发了ol.Map的单击事件：singleclick'; &#125;); // 响应双击事件 map.on('dblclick', function(event)&#123; document.getElementById('info').innerHTML = '触发了ol.Map的双击事件：dblclick'; &#125;); // 响应点击事件 map.on('click', function(event)&#123; document.getElementById('info').innerHTML = '触发了ol.Map的点击事件：click'; &#125;); // 响应鼠标移动事件，事件太频繁，故注释掉了，可自行验证该事件 // map.on('pointermove', function(event)&#123; // document.getElementById('info').innerHTML = '触发了ol.Map的鼠标移动事件：pointermove'; // &#125;); // 响应拖拽事件 map.on('pointerdrag', function(event)&#123; document.getElementById('info').innerHTML = '触发了ol.Map的拖拽事件：pointerdrag'; &#125;); // 地图移动事件 map.on('moveend', function(event)&#123; document.getElementById('info').innerHTML = '触发了ol.Map的地图移动事件：moveend'; &#125;);&lt;/script&gt;## 非直接交互事件### 地图缩放事件对应的类为ol.View，事件名为 change:resolution，为什么？ 因为分辨率改变了，自然层级就变化了。### 地图中心改变事件对应的类是ol.View，事件名为 change:center。下面这个地图，可以让你感受一下这两个事件：事件提示信息 var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: ‘map2’, view: new ol.View({ center: ol.proj.transform( [104, 30], ‘EPSG:4326’, ‘EPSG:3857’), zoom: 10 }) }); var view = map2.getView(); view.on(‘change:resolution’, function(event){ document.getElementById(‘info2’).innerHTML = ‘触发了ol.View的缩放事件：change:resolution，当前层级为： ‘ + this.getZoom(); }); view.on(‘change:center’, function(event){ document.getElementById(‘info2’).innerHTML = ‘触发了ol.View的地图中心改变事件：change:center，当前中心点为： ‘ + ol.proj.transform( this.getCenter(), ‘EPSG:3857’, ‘EPSG:4326’); });### 改变事件OpenLayers 3的大多数类都拥有一些改变事件，这些事件常用于模块之间联动使用，在二次开发的业务需求中，也会经常需要，所以希望能引起重视，具体的事件可以参照API官网文档的说明。 比如上面的例子其实就是应用的这类事件。# 阻止事件传递# 自定义事件及应用通过API文档，我们可以看到OpenLayers 3的相关类，都有一些事件，但这些事件大多是和现有引擎相关的，并不能满足我们大多数的业务需求。如果能为OpenLayers 3的类增加自定义事件，那么必然能更好地实现业务需求。接下来就尝试为ol.Feature添加一个mouseover的事件，通过这个事件，就可以实现在鼠标移到Feature上时，改变它的样式。要添加自定义事件，需要知道这样一个事实：ol.Feature继承于ol.Object，而ol.Object具有派发事件(dispatchEvent)和监听事件(on)的功能。 关于这两个功能的详细信息可以参见API文档。这样，我们要自定义事件就非常容易了，如果注意观察，会发现OpenLayers 3中的类都继承于ol.Object，也就是说，如果自定义事件方法在ol.Feature上有效，那么在其他的OpenLayers 3的类上也是同样有效的。下面就先展示一下通过自定义的mouseover事件来改变Feature的样式： // 在原点处创建一个feature var feature1 = new ol.Feature({ geometry: new ol.geom.Point([0, 0]) }); // 并设置为半径为100像素的圆，用红色填充 feature1.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 100, fill: new ol.style.Fill({ color: 'red' }) }) })); // 在坐标[5000000, 5000000]处创建另一个feature var feature2 = new ol.Feature({ geometry: new ol.geom.Point([5000000, 5000000]) }); // 并设置为半径为100像素的圆，用黄色填充 feature2.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 100, fill: new ol.style.Fill({ color: 'yellow' }) }) })); // 创建地图 var map = new ol.Map({ // 设置地图图层 layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile({source: new ol.source.OSM()}), // 把之前创建的feature1和feature2放在另一个层里 new ol.layer.Vector({source: new ol.source.Vector({ features: [feature1, feature2] })}) ], // 设置显示地图的视图 view: new ol.View({ center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 }), // 让id为map的div作为地图的容器 target: 'map' }); // 为地图注册鼠标移动事件的监听 map.on('pointermove', function(event){ map.forEachFeatureAtPixel(event.pixel, function(feature){ // 为移动到的feature发送自定义的mousemove消息 feature.dispatchEvent({type: 'mousemove', event: event}); }); }); // 为feature1注册自定义事件mousemove的监听 feature1.on('mousemove', function(event){ // 修改feature的样式为半径100像素的园，用蓝色填充 this.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 100, fill: new ol.style.Fill({ color: 'blue' }) }) })); }); 为了对比，在地图上添加了两个圆，一个黄色的，一个红色的。鼠标移动到红色的圆上，它会变成蓝色的圆。但是鼠标移到黄色的圆上，不会有任何改变。这个功能在官网的例子中也有，参见select-features。那么用自定义事件的方式来做，又该怎样来实现呢？对应的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!Doctype html&gt;&lt;html xmlns=http://www.w3.org/1999/xhtml&gt;&lt;head&gt; &lt;meta http-equiv=Content-Type content=\"text/html;charset=utf-8\"&gt; &lt;meta http-equiv=X-UA-Compatible content=\"IE=edge,chrome=1\"&gt; &lt;meta content=always name=referrer&gt; &lt;title&gt;OpenLayers 3地图示例&lt;/title&gt; &lt;link href=\"../src/ol3.13.1/ol.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;script type=\"text/javascript\" src=\"../src/ol3.13.1/ol.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%, height: 400px\"&gt;&lt;/div&gt; &lt;script&gt; // 在原点处创建一个feature var feature1 = new ol.Feature(&#123; geometry: new ol.geom.Point([0, 0]) &#125;); // 并设置为半径为100像素的圆，用红色填充 feature1.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 100, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;)); // 在坐标[5000000, 5000000]处创建另一个feature var feature2 = new ol.Feature(&#123; geometry: new ol.geom.Point([5000000, 5000000]) &#125;); // 并设置为半径为100像素的圆，用黄色填充 feature2.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 100, fill: new ol.style.Fill(&#123; color: 'yellow' &#125;) &#125;) &#125;)); // 创建地图 var map = new ol.Map(&#123; // 设置地图图层 layers: [ // 创建一个使用Open Street Map地图源的瓦片图层 new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;), // 把之前创建的feature1和feature2放在另一个层里 new ol.layer.Vector(&#123;source: new ol.source.Vector(&#123; features: [feature1, feature2] &#125;)&#125;) ], // 设置显示地图的视图 view: new ol.View(&#123; center: [0, 0], // 定义地图显示中心于经度0度，纬度0度处 zoom: 2 // 并且定义地图显示层级为2 &#125;), // 让id为map的div作为地图的容器 target: 'map' &#125;); // 为地图注册鼠标移动事件的监听 map.on('pointermove', function(event)&#123; map.forEachFeatureAtPixel(event.pixel, function(feature)&#123; // 为移动到的feature发送自定义的mousemove消息 feature.dispatchEvent(&#123;type: 'mousemove', event: event&#125;); &#125;); &#125;); // 为feature1注册自定义事件mousemove的监听 feature1.on('mousemove', function(event)&#123; // 修改feature的样式为半径100像素的园，用蓝色填充 this.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 100, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;)); &#125;); &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 代码中有详细的注释，再辅以API文档，相信应该看懂绝大部分的代码，当然最关键的代码在于最后的两个事件监听，在这两段代码中，可能下面这句不是很明白：1feature.dispatchEvent(&#123;type: 'mousemove', event: event&#125;); dispatchEvent的参数具有type和event属性，必须这样构造吗？在回答这个问题之前，需要先看一下API文档，发现参数类型为goog.events.EventLike，说明它其实用的是google的closure库来实现的，通过closure库的源码我们知道，派发的事件如果是一个对象，那么必须包含type属性，用于表示事件类型。其他的属性可以自由定义，比如此处定义了event属性，并设置对应的值，为的是让鼠标事件传递给feature1的监听函数。 dispatchEvent的参数会被原封不动的传递给事件响应函数，对应代码1feature1.on('mousemove', function(event)&#123; 里function的参数event，可以通过调试窗口看到此处的event和dispatchEvent的参数是一样的。注意事件名称是可以自定义的，只要派发和监听使用的事件名称是一致的就可以。 除了可以通过dispatchEvent({type: &#39;mousemove&#39;, event: event})这种形式派发一个事件之外，还可以通过dispatchEvent(&#39;mousemove&#39;)这中形式直接发送mousemove事件。有兴趣的同学可以自行验证。 到此，我们就完成了自定义事件的三件事：定义事件类型，派发事件，监听事件。 使用自定义事件会带来下面几个好处： 灵活控制，对比一下官网例子和这个例子，就能看出一二。 能更好地满足业务需要，适当地进行扩展。 采用更统一的事件处理框架。 有很多同学为了处理多个Feature的鼠标事件，可能会为Map注册很多次pointermove事件监听，从而会导致性能降低，这种做法是不可取的。如果采用上面这种自定义事件的处理方式，就只用注册一次，让真正有需要的Feature通过注册事件响应来处理业务，从而还能简化处理逻辑。 上面这个例子鼠标移到红色圆后变蓝色，但是移出圆后，还是蓝色，能不能再移出圆的时候再变成红色呢？ 试试用自定义事件的方式再改进一下，实现mousein和mouseout两种事件。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 图标及提示信息","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch07/index.html","text":"图标及提示信息图标是GIS应用中必不可少的要素，比如在地图上标注饭店，学校，加油站等，就需要添加图标，点击图标，可能需要提示更为详细的信息，比如地址，评价，或者更为复杂的业务信息。本节将从基本的应用入手讲解，直到比较高级一些的自定义特色图标和信息展示。 应用overlay在OpenLayer3中添加图标有两种方式，一种是我们这一小节马上就要介绍的，比较传统的overlay，另一种是下一小节马上就要介绍的Feature + Style的方式。 overlay之所以传统，是因为它就是传统的html方式显示图片。 下面就是用这种方式加载一个锚点的示例： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: ‘map’, view: new ol.View({ projection: ‘EPSG:4326’, center: [104, 30], zoom: 10 }) }); var anchor = new ol.Overlay({ element: document.getElementById(‘anchor’) }); anchor.setPosition([104, 30]); map.addOverlay(anchor);代码如下：123456789101112131415161718192021222324252627&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;!--下面就是传统的显示一个图片图标的方式，用img--&gt;&lt;div id=\"anchor\"&gt;&lt;img src=\"../img/anchor.png\" alt=\"示例锚点\"/&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 下面把上面的图标附加到地图上，需要一个ol.Overlay var anchor = new ol.Overlay(&#123; element: document.getElementById('anchor') &#125;); // 关键的一点，需要设置附加到地图上的位置 anchor.setPosition([104, 30]); // 然后添加到map上 map.addOverlay(anchor);&lt;/script&gt;代码的说明参加注释，最终效果是在地图中间有一个锚点图标。## 缺点当图标比较多的情况下，如果采用这种方式，那么我们会加入非常多的HTML元素，从而造成效率降低。 关于效率的测试，大家可以自行测试。 为什么会这样呢？ 因为界面上元素的遍历在数量比较多的情况下，会变慢，基于此基础上的渲染，鼠标事件都会变慢。## 优点这种使用传统的方式显示图标可以应用传统的HTML技术，比如鼠标移动到图标上，鼠标图标变成手势。 我们可以用css来处理就可以了，比如在head里面添加下面的代码： #anchor { cursor:pointer; }12345&lt;style type=\"text/css\"&gt; #anchor &#123; cursor:pointer; &#125;&lt;/style&gt;就可以看到鼠标放到锚点上去的时候，鼠标图标从箭头，变成手了。 类似的其他技术都可以应用上去，比如css动画。 鉴于动画在前端的重要性，下面单独分出一个小节用实例来讲解。# 动画图标动起来的图标会更有吸引力，下面用overlay+css的方式来实现： @keyframes zoom { from {top: 0; left: 0; width: 32px; height: 32px;} 50% {top: -16px; left: -16px; width: 64px; height: 64px;} to {top: 0; left: 0; width: 32px; height: 32px;} } @-moz-keyframes zoom / Firefox / { from {top: 0; left: 0; width: 32px; height: 32px;} 50% {top: -16px; left: -16px; width: 64px; height: 64px;} to {top: 0; left: 0; width: 32px; height: 32px;} } @-webkit-keyframes zoom / Safari 和 Chrome / { from {top: 0; left: 0; width: 32px; height: 32px;} 50% {top: -16px; left: -16px; width: 64px; height: 64px;} to {top: 0; left: 0; width: 32px; height: 32px;} } @-o-keyframes zoom / Opera / { from {top: 0; left: 0; width: 32px; height: 32px;} 50% {top: -16px; left: -16px; width: 64px; height: 64px;} to {top: 0; left: 0; width: 32px; height: 32px;} } #anchorImg { display: block; position: absolute; animation: zoom 5s; animation-iteration-count: infinite; -moz-animation: zoom 5s; / Firefox / -moz-animation-iteration-count: infinite; -webkit-animation: zoom 5s; / Safari 和 Chrome / -webkit-animation-iteration-count: infinite; -o-animation: zoom 5s; / Opera / -o-animation-iteration-count: infinite; } var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor = new ol.Overlay({ element: document.getElementById('anchor') }); anchor.setPosition([104, 30]); map.addOverlay(anchor); 代码和之前的例子差不多，只是多了css动画的设置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;head&gt; &lt;!--定义动画，图标先放大，再缩小--&gt; &lt;style type=\"text/css\"&gt; @keyframes zoom &#123; from &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; 50% &#123;top: -16px; left: -16px; width: 64px; height: 64px;&#125; to &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; &#125; @-moz-keyframes zoom /* Firefox */ &#123; from &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; 50% &#123;top: -16px; left: -16px; width: 64px; height: 64px;&#125; to &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; &#125; @-webkit-keyframes zoom /* Safari 和 Chrome */ &#123; from &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; 50% &#123;top: -16px; left: -16px; width: 64px; height: 64px;&#125; to &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; &#125; @-o-keyframes zoom /* Opera */ &#123; from &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; 50% &#123;top: -16px; left: -16px; width: 64px; height: 64px;&#125; to &#123;top: 0; left: 0; width: 32px; height: 32px;&#125; &#125; /* 应用css动画到图标元素上 */ #anchorImg &#123; display: block; position: absolute; animation: zoom 5s; animation-iteration-count: infinite; /* 一直重复动画 */ -moz-animation: zoom 5s; /* Firefox */ -moz-animation-iteration-count: infinite; /* 一直重复动画 */ -webkit-animation: zoom 5s; /* Safari 和 Chrome */ -webkit-animation-iteration-count: infinite; /* 一直重复动画 */ -o-animation: zoom 5s; /* Opera */ -o-animation-iteration-count: infinite; /* 一直重复动画 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;div id=\"anchor\" style=\"width: 64px;height: 64px;\" &gt;&lt;img id='anchorImg' src=\"../img/anchor.png\" alt=\"示例锚点\"/&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); var anchor = new ol.Overlay(&#123; element: document.getElementById('anchor') &#125;); anchor.setPosition([104, 30]); map.addOverlay(anchor);&lt;/script&gt; 除了这种css实现动画之外，你还可以直接加载gif动画，这是非常简单的，再此不表。 设置图标位置如果像之前那样设置图标，不做任何位置设置，那么默认情况下，图标的中心点对应于地图位置。下面这个地图显示了这个位置，中心那个红点所处位置就是[104, 30]，可以这个点对应于图标的中心位置： var layer2 = new ol.layer.Vector({ source: new ol.source.Vector() }) var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer2 ], target: 'map2', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor2 = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); anchor2.setStyle(new ol.style.Style({ image: new ol.style.Icon({ src: '../img/anchor.png' }) })); layer2.getSource().addFeature(anchor2); var refFeature = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }) refFeature.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 2, fill: new ol.style.Fill({ color: 'red' }) }) })); layer2.getSource().addFeature(refFeature); 有时候我们可能并不想这样，比如我们希望锚点图标下方的箭头指向地图位置。 比如这样： var layer3 = new ol.layer.Vector({ source: new ol.source.Vector() }) var map3 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer3 ], target: 'map3', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor3 = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); anchor3.setStyle(new ol.style.Style({ image: new ol.style.Icon({ src: '../img/anchor.png', anchor: [0.5, 1] }) })); layer3.getSource().addFeature(anchor3); var refFeature3 = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }) refFeature3.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 2, fill: new ol.style.Fill({ color: 'red' }) }) })); layer3.getSource().addFeature(refFeature3); 要做到这个效果，我们只需要把设置样式的代码加上anchor的设置： 1234image: new ol.style.Icon(&#123; src: '../img/anchor.png', anchor: [0.5, 1] // 设置图标位置&#125;) 为什么是[0.5, 1]这种值，表示什么？ 默认情况下，位置坐标是按照比例的方式来设置的，范围从0到1，x轴上0表示最左边，1表示最右边，y轴上0表示最上边，1表示最下边。 如代码所示，x设置为0.5可以让图片在x方向上居中，y设置为1可以让图片在y方向上移动到最底端。 大家可以给予上面这个代码修改一下，试试[0, 0]会让图标处于什么位置？ 除了按照比例进行移动之外，还可以按照像素来计算位置，但必须显示设置anchorXUnits或 anchorYUnits为pixels。 根据不同的需要，可以采用不同的单位来设置。 根据层级放大缩小图标由于图标不会跟随图层的放大缩小而放大缩小，所以在某些业务应用中，可能并不合适，需要也跟随变化。 之前就有同学提到这个问题，在ol.style.Icon中是可以设置scale的，这样就为我们提供了方便。 通过设置它，就可以做到。 下面这个地图中的锚点图标，就会随着地图放大缩小而变化大小： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); anchor.setStyle(new ol.style.Style({ image: new ol.style.Icon({ src: '../img/anchor.png' }) })); layer.getSource().addFeature(anchor); map.getView().on('change:resolution', function(){ var style = anchor.getStyle(); style.getImage().setScale(this.getZoom() / 10); anchor.setStyle(style); }) 和之前的代码绝大部分都是相同的：1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); var anchor = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); anchor.setStyle(new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/anchor.png' &#125;) &#125;)); layer.getSource().addFeature(anchor); // 监听地图层级变化 map.getView().on('change:resolution', function()&#123; var style = anchor.getStyle(); // 重新设置图标的缩放率，基于层级10来做缩放 style.getImage().setScale(this.getZoom() / 10); anchor.setStyle(style); &#125;)&lt;/script&gt; 利用一个监听和scale改变，就实现了这个同比缩放。 具体缩放多少，请根据业务来设置，可以设置的更加精细，此处只是功能示例。 其实还有另外一种方式，可以实现动态缩放大小，参见styleFunction应用。 另类设置svg图标图标除了可以直接设置png的文件url之外，也可以设置svg的文件url，但这并不是唯一的加载svg图标的方式。 OpenLayers 3提供了直接使用图像对象来设置的方式，对应于ol.style.Icon构造函数中的img参数。 如下： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); // 构建svg的Image对象 var svg = ''+ ''+ ''; var mysvg = new Image(); mysvg.src = 'data:image/svg+xml,' + escape(svg); anchor.setStyle(new ol.style.Style({ image: new ol.style.Icon({ img: mysvg, // 设置Image对象 imgSize: [30, 30] // 及图标大小 // src: 'http://www.williambuck.com/portals/0/Skins/WilliamBuck2014/images/location-icon.svg', // size: [30, 30] }) })); layer.getSource().addFeature(anchor); 对应的代码：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); var anchor = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); // 构建svg的Image对象 var svg = '&lt;svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"30px\" height=\"30px\" viewBox=\"0 0 30 30\" enable-background=\"new 0 0 30 30\" xml:space=\"preserve\"&gt;'+ '&lt;path fill=\"#156BB1\" d=\"M22.906,10.438c0,4.367-6.281,14.312-7.906,17.031c-1.719-2.75-7.906-12.665-7.906-17.031S10.634,2.531,15,2.531S22.906,6.071,22.906,10.438z\"/&gt;'+'&lt;circle fill=\"#FFFFFF\" cx=\"15\" cy=\"10.677\" r=\"3.291\"/&gt;&lt;/svg&gt;'; var mysvg = new Image(); mysvg.src = 'data:image/svg+xml,' + escape(svg); anchor.setStyle(new ol.style.Style(&#123; image: new ol.style.Icon(&#123; img: mysvg, // 设置Image对象 imgSize: [30, 30] // 及图标大小// src: 'http://www.williambuck.com/portals/0/Skins/WilliamBuck2014/images/location-icon.svg',// size: [30, 30] &#125;) &#125;)); layer.getSource().addFeature(anchor);&lt;/script&gt; 前半部分代码都一样，最后设置样式的时候，可以根据注释来理解不一样的代码，构建Image对象，设置src是关键。 规则几何体图标相对于png而言，svg这样的矢量图在放大缩小方面更清晰，但对于规则几何体而言，如果也使用svg，未免复杂了一点，OpenLayers 3为了简化这样的操作，提供了一个规则几何体的样式类ol.style.RegularShape，使用它可以轻松绘制正方形，三角形等,也支持星形规则几何图形，比如下面这样： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var shape = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); shape.setStyle(new ol.style.Style({ image: new ol.style.RegularShape({ points: 3, radius: 10, stroke: new ol.style.Stroke({ color: 'red', size: 2 }) }) })); layer.getSource().addFeature(shape); var star = new ol.Feature({ geometry: new ol.geom.Point([104.1, 30.1]) }); star.setStyle(new ol.style.Style({ image: new ol.style.RegularShape({ points: 5, radius1: 20, radius2: 10, stroke: new ol.style.Stroke({ color: 'red', size: 2 }), fill: new ol.style.Fill({ // 设置五星填充样式 color: 'blue' }) }) })); layer.getSource().addFeature(star); 图上有一个三角形，一个5星，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 添加一个三角形 var shape = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); shape.setStyle(new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 3, // 顶点数 radius: 10, // 图形大小，单位为像素 stroke: new ol.style.Stroke(&#123; // 设置边的样式 color: 'red', size: 2 &#125;) &#125;) &#125;)); layer.getSource().addFeature(shape); // 添加一个五星 var star = new ol.Feature(&#123; geometry: new ol.geom.Point([104.1, 30.1]) &#125;); star.setStyle(new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 5, // 顶点个数 radius1: 20, // 外圈大小 radius2: 10, // 内圈大小 stroke: new ol.style.Stroke(&#123; // 设置边的样式 color: 'red', size: 2 &#125;), fill: new ol.style.Fill(&#123; // 设置五星填充样式 color: 'blue' &#125;) &#125;) &#125;)); layer.getSource().addFeature(star);&lt;/script&gt; 除了基本的设置之外，还支持图形旋转，以及跟随地图旋转而旋转，这些设置在其他的应用中也多有涉及，此处不再用实例来介绍，可自行验证。 用Canvas自绘图标除了规则的几何体之外，往往需要定义一些不规则的几何体，可以使用svg来实现，但也可以用canvas自己来绘制，比如像下面这个图标： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); // 使用canvas绘制一个不规则几何图形 var canvas =document.createElement('canvas'); canvas.width = 20; canvas.height = 20; var context = canvas.getContext(\"2d\"); context.strokeStyle = \"red\"; context.lineWidth = 1; context.beginPath(); context.moveTo(0, 0); context.lineTo(20, 10); context.lineTo(0, 20); context.lineTo(10, 10); context.lineTo(0, 0); context.stroke(); // 把绘制了的canvas设置到style里面 var style = new ol.style.Style({ image: new ol.style.Icon({ img: canvas, imgSize: [canvas.width, canvas.height], rotation: 90 * Math.PI / 180 }) }); // 创建一个Feature var shape = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); // 应用具有不规则几何图形的样式到Feature shape.setStyle(style); layer.getSource().addFeature(shape); 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 使用canvas绘制一个不规则几何图形 var canvas =document.createElement('canvas'); canvas.width = 20; canvas.height = 20; var context = canvas.getContext(\"2d\"); context.strokeStyle = \"red\"; context.lineWidth = 1; context.beginPath(); context.moveTo(0, 0); context.lineTo(20, 10); context.lineTo(0, 20); context.lineTo(10, 10); context.lineTo(0, 0); context.stroke(); // 把绘制了的canvas设置到style里面 var style = new ol.style.Style(&#123; image: new ol.style.Icon(&#123; img: canvas, imgSize: [canvas.width, canvas.height], rotation: 90 * Math.PI / 180 &#125;) &#125;); // 创建一个Feature var shape = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); // 应用具有不规则几何图形的样式到Feature shape.setStyle(style); layer.getSource().addFeature(shape);&lt;/script&gt; 和svg的那个例子一样，使用了ol.style.Icon样式的img属性来设置，需要注意的是，必须设置imgSize属性，因为仅仅通过img设置的图像对象，没有办法自动获取宽高。 同时，官网也提供了一个类似的例子earthquake-custom-symbol，只是使用OpenLayers3 内部提供的封装库来绘制图像到canvas上，原理一样。 有了这种方式之后，相信做任何图标都不会遇到难题了。 动态改变图标在实际业务应用中，需要根据环境条件，动态的修改图标样式，以反馈数据变化。 比如像下面这样，点击五星，五星图标会用红色填充： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var star = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); star.setStyle(new ol.style.Style({ image: new ol.style.RegularShape({ points: 5, radius1: 20, radius2: 10, stroke: new ol.style.Stroke({ color: 'red', size: 2 }) }) })); layer.getSource().addFeature(star); map.on('click', function(event){ var feature = map.forEachFeatureAtPixel(event.pixel, function(feature){ return feature; }); if (feature) { var style = feature.getStyle().getImage(); feature.setStyle(new ol.style.Style({ image: new ol.style.RegularShape({ points: 5, radius1: 20, radius2: 10, stroke: style.getStroke(), fill: new ol.style.Fill({ color: 'red' }) }) })); } }); 对应的代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 添加一个空心的五星 var star = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); star.setStyle(new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 5, radius1: 20, radius2: 10, stroke: new ol.style.Stroke(&#123; color: 'red', size: 2 &#125;) &#125;) &#125;)); layer.getSource().addFeature(star); // 监听地图点击事件 map.on('click', function(event)&#123; var feature = map.forEachFeatureAtPixel(event.pixel, function(feature)&#123; return feature; &#125;); if (feature) &#123; // 将空心五星为红色实心五星 var style = feature.getStyle().getImage(); feature.setStyle(new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 5, radius1: 20, radius2: 10, stroke: style.getStroke(), fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;)); &#125; &#125;);&lt;/script&gt; 文字标注前面基本都在围绕着图标进行说明，其实用Feature + Style的方式，也是可以单独添加文字的，虽然简单，但可能有些同学会忽略这样的做法，所以在此用一个简单的示例来说明： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104.06, 30.67], zoom: 10 }) }); var anchor = new ol.Feature({ geometry: new ol.geom.Point([104.06, 30.67]) }); anchor.setStyle(new ol.style.Style({ text: new ol.style.Text({ text: '淡叔所在地成都', fill: new ol.style.Fill({ color: 'red' }) }) })); layer.getSource().addFeature(anchor); 代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104.06, 30.67], zoom: 10 &#125;) &#125;); var anchor = new ol.Feature(&#123; geometry: new ol.geom.Point([104.06, 30.67]) &#125;); // 设置文字style anchor.setStyle(new ol.style.Style(&#123; text: new ol.style.Text(&#123; // font: '10px sans-serif' 默认这个字体，可以修改成其他的，格式和css的字体设置一样 text: '淡叔所在地成都', fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;)); layer.getSource().addFeature(anchor);&lt;/script&gt; 还有很多属性可以设置，比如缩放，旋转，以及位移等等，非常简单，可自行设置调试。 style及应用前面已经介绍了第一种加载图标的方式，现在介绍第二种方式，使用Feature + Style来实现，用这种方式实现之前的效果如下： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); anchor.setStyle(new ol.style.Style({ image: new ol.style.Icon({ src: '../img/anchor.png' }) })); layer.getSource().addFeature(anchor); 代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 我们需要一个vector的layer来放置图标 var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 创建一个Feature，并设置好在地图上的位置 var anchor = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); // 设置样式，在样式中就可以设置图标 anchor.setStyle(new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/anchor.png' &#125;) &#125;)); // 添加到之前的创建的layer中去 layer.getSource().addFeature(anchor);&lt;/script&gt; 效果是一样的，但从代码上来看，是不一样的: 首先overlay需要HTML元素img，但这种方式不需要 overlay是添加在map上的，但是这种方式需要一个Vector的layer，并添加在其上 我们没有办法像overlay那样使用一些HTML技术 应用虽然不能用css直接修改图标显示，但并不是说使用这种方式没有自定义的余地，大家可以先在官网API上看一下ol.style.Icon的构造参数，会看到可以设置位置，透明度，放大缩小，旋转等，基本能满足大多数的应用，由于和CSS不同，很多同学在应用时遇到一些问题，所以下面给出了一些具体的使用示例。 styleFunction应用很多时候，我们会忽略styleFunction的存在，但很明显的，它可以让我们的图标或者标签应用更加灵活，比如根据层级放大缩小图标也可以用styleFunction来实现： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }) var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var anchor = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); anchor.setStyle(function(resolution){ return [new ol.style.Style({ image: new ol.style.Icon({ src: '../img/anchor.png', scale: map.getView().getZoom() / 10 }) })]; }); layer.getSource().addFeature(anchor); 代码如下：1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;) var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); var anchor = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); // 应用style function，动态的获取样式 anchor.setStyle(function(resolution)&#123; return [new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/anchor.png', scale: map.getView().getZoom() / 10 &#125;) &#125;)]; &#125;); layer.getSource().addFeature(anchor);&lt;/script&gt; 对比一下前面同样功能的代码，你会发现这样更加的简单， 同时在此基础上扩展开来的应用也会更加的多。 比如动态替换图标，或者让图标不显示等等，可自行来实现这两个需求，以掌握此方式的使用。 在上面这个例子中，我们是在feature上应用了styleFunction，通过官网API文档可以看到，其类型为ol.FeatureStyleFunction，函数仅带有一个参数resolution，在上面的代码中看到了，在函数体内this指的是当前的feature，根据文档说明，这个函数要范围一个style数组。 这一点需要注意，虽然实际使用中，即使没有返回数组也不会出错，但还是希望大家能遵守官网API的说明来使用该接口。 我们知道，除了feature可以设置样式之外，layer也是可以设置样式的，同样地也支持styleFunction，但是需要注意的是，其定义和feature的不一样，类型为ol.style.StyleFunction，该函数具有两个参数，第一个参数为feature，第二个参数为resolution，同样地，该函数需要返回style数组。 styleFunction在feature上具有很好的灵活性，那么应用在layer上，同样威力无穷，比如像下面这个： var layerStyleFunction = function(feature, resolution) { var type = feature.get('type'); var style = null; if (type === 'point') { style = new ol.style.Style({ image: new ol.style.Circle({ radius: 1, fill: new ol.style.Fill({ color: 'red' }) }) }); } else if ( type === 'circle') { style = new ol.style.Style({ image: new ol.style.Circle({ radius: 10, stroke: new ol.style.Stroke({ color: 'red', size: 1 }) }) }); } else { style = new ol.style.Style({ image: new ol.style.RegularShape({ points: 5, radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) }); } return [style]; }; var layer2 = new ol.layer.Vector({ source: new ol.source.Vector(), style: layerStyleFunction }); var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer2 ], target: 'map2', view: new ol.View({ projection: 'EPSG:4326', center: [104, 30], zoom: 10 }) }); var rect = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); layer2.getSource().addFeature(rect); var circle = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); circle.set('type', 'circle'); layer2.getSource().addFeature(circle); var point = new ol.Feature({ geometry: new ol.geom.Point([104, 30]) }); point.set('type', 'point'); layer2.getSource().addFeature(point); 在地图上可以看到中心位置有一个圆，一个点，一个五边形，但这次都没有直接在这些feature上设置样式，具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 创建layer使用的style function，根据feature的自定义type，返回不同的样式 var layerStyleFunction = function(feature, resolution) &#123; var type = feature.get('type'); var style = null; // 点 if (type === 'point') &#123; style = new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 1, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;); &#125; else if ( type === 'circle') &#123; // 圆形 style = new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;); &#125; else &#123; // 其他形状 style = new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 5, radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;); &#125; // 返回 style 数组 return [style]; &#125;; var layer2 = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: layerStyleFunction // 应用上面创建的 style function &#125;); var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer2 ], target: 'map2', view: new ol.View(&#123; projection: 'EPSG:4326', center: [104, 30], zoom: 10 &#125;) &#125;); // 添加三个feature，并设置自定义属性 type var rect = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); layer2.getSource().addFeature(rect); var circle = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); circle.set('type', 'circle'); layer2.getSource().addFeature(circle); var point = new ol.Feature(&#123; geometry: new ol.geom.Point([104, 30]) &#125;); point.set('type', 'point'); layer2.getSource().addFeature(point);&lt;/script&gt; 这就是一个典型的根据feature的属性进行不同渲染的例子，可以在业务上无限扩展，比如feature的属性可以是速度，可以是大小，可以是时间，可以是权重等等。 由此可见，只要掌握了这个方法，前端按照条件渲染就不再困难。 大量图标方案此处的大量图标方案，不涉及服务器端，如果图标不进行交互，可以把图标渲染到底图上。 此处只介绍说明在前端可交互的大量图标方案，在图标数量不大的情况，无论使用什么方式加载，都不会有性能问题，当图标多了之后，就会出现卡顿，内存占用增大等问题。 在OpenLayers 3开发中，可以考虑下面两个方案来解决这个问题。 复用样式减少内存占用在应用大量图标的时候，其实图标样式差异化并不大，比如快餐店，公共厕所，公交站点等等有很多，但都是用同样的图标在地图上标准，在不注意的时候，我们是采用下面的方式来添加图标的： 12345678910for (var index = 0; index &lt; 10000; index++) &#123; var feature = new ol.Feature(&#123; geometry: new ol.geom.Point([latlon[index].lon, latlon[index].lat]) &#125;); feature.setStyle(new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/marker.png' &#125;) &#125;));&#125; 注意上面代码，对每个feature设置style的时候，都是直接new的，这样势必会创建很多对象，占用很多内存。 那么复用必然减少很多内存，重构上面的代码为： 1234567891011var style = new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/marker.png' &#125;)&#125;);for (var index = 0; index &lt; 10000; index++) &#123; var feature = new ol.Feature(&#123; geometry: new ol.geom.Point([latlon[index].lon, latlon[index].lat]) &#125;); feature.setStyle(style);&#125; 这样，我们就只创建了一个style对象，那么势必减少内存占用。 如果有多类图标，可以用数组缓存下来： 12345678910111213141516171819202122232425var styles = [ new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/marker1.png' &#125;) &#125;), new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/marker2.png' &#125;) &#125;), new ol.style.Style(&#123; image: new ol.style.Icon(&#123; src: '../img/marker3.png' &#125;) &#125;)];for (var index = 0; index &lt; 10000; index++) &#123; var feature = new ol.Feature(&#123; geometry: new ol.geom.Point([latlon[index].lon, latlon[index].lat]) &#125;); feature.setStyle(styles[index % styles.length]);&#125; 由于官网有实际的例子，大家请移步到icon-sprite-webgl。 下面是其中的一些代码片段，在里面加入了一些注释，便于大家理解： 12345678910111213141516171819202122232425262728// 预先设置好要使用的style，并缓存在icons数组中for (i = 0; i &lt; iconCount; ++i) &#123; var info = iconInfo[i]; icons[i] = new ol.style.Icon(&#123; offset: info.offset, opacity: info.opacity, rotateWithView: info.rotateWithView, rotation: info.rotation, scale: info.scale, size: info.size, src: 'data/Butterfly.png' &#125;);&#125;......for (i = 0; i &lt; featureCount; ++i) &#123; geometry = new ol.geom.Point( [2 * e * Math.random() - e, 2 * e * Math.random() - e]); feature = new ol.Feature(geometry); feature.setStyle( new ol.style.Style(&#123; // 直接使用上面缓存的icons里面的样式 image: icons[i % (iconCount - 1)] &#125;) ); features[i] = feature;&#125; 大家可在官网例子的基础上修改一下代码，验证一下复用和不复用的情况下，内存占用相差多少。 复用Canvas提高效率采用上一种方式基本能解决掉绝大部分的问题，但是OpenLayers 3还提供了一种复用图标渲染使用的Canvas的方式，对应的类是ol.style.AtlasManager。 在了解其作用之前，需要先了解一点图标的渲染机制，比如ol.style.Circle和ol.style.RegularShape这样的图标，在内部渲染时，都会创建一个HTML的canvas，然后在这个画布上绘制图像，然后再把图像复制到地图上。 这样创建一个图标，就会在内部创建一个canvas。 ol.style.AtlasManager解决的问题就是，用一个大的canvas来绘制多个图标，这样就能减少canvas的数量，从而提高效率。 官网有一个具体的例子来说明这种方法的使用，参见Symbols with WebGL。 其中，关键的代码在： 123456789101112131415161718192021222324var atlasManager = new ol.style.AtlasManager(&#123; // we increase the initial size so that all symbols fit into // a single atlas image initialSize: 512&#125;);...... // circle symbol symbols.push(new ol.style.Circle(&#123; opacity: info.opacity, scale: info.scale, radius: radiuses[j], fill: new ol.style.Fill(&#123; color: info.fillColor &#125;), stroke: new ol.style.Stroke(&#123; color: info.strokeColor, width: 1 &#125;), // by passing the atlas manager to the symbol, // the symbol will be added to an atlas atlasManager: atlasManager // 注意：在创建style的这个地方设置了 atlasManager &#125;)); 需要注意的是，在API官方文档上，并没有这个属性的设置，但内部实现是有这个优化的。 同时需要注意的是经常使用的ol.style.Icon目前是没有实现这个优化的。 提示信息提示信息在很多业务场景中都需要，比如显示当前位置周边的饭店列表，或者点击饭店，显示饭店详细信息，交通路线，电话号码等等。 鉴于显示的业务信息比较多，所以通常的做法都是采用overlay的方式来做。 用传统的HTML来布局和排版信息，然后附加到地图上的指定位置就可以了。 官网中提供了一个具体的例子： popup。 下面就解读一下这个例子的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--此处用html布局，各种样式均在css中定义好了--&gt;&lt;div id=\"popup\" class=\"ol-popup\"&gt; &lt;a href=\"#\" id=\"popup-closer\" class=\"ol-popup-closer\"&gt;&lt;/a&gt; &lt;div id=\"popup-content\"&gt;&lt;/div&gt;&lt;/div&gt;......&lt;script&gt; // 获取到popup的节点 var container = document.getElementById('popup'); var content = document.getElementById('popup-content'); var closer = document.getElementById('popup-closer'); // 创建一个overlay, 绑定html元素container var overlay = new ol.Overlay(/** @type &#123;olx.OverlayOptions&#125; */ (&#123; element: container, autoPan: true, autoPanAnimation: &#123; duration: 250 &#125; &#125;)); ...... // 监听地图点击事件 map.on('singleclick', function(evt) &#123; // 获取当前点击坐标，并设置到HTML元素上去 var coordinate = evt.coordinate; var hdms = ol.coordinate.toStringHDMS(ol.proj.transform( coordinate, 'EPSG:3857', 'EPSG:4326')); content.innerHTML = '&lt;p&gt;You clicked here:&lt;/p&gt;&lt;code&gt;' + hdms + '&lt;/code&gt;'; // 设置overlay的位置，从而显示在鼠标点击处 overlay.setPosition(coordinate); &#125;);&lt;/script&gt;","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 内置交互方式介绍","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch09/index.html","text":"Interaction交互是人机界面非常重要的一个部分，任何一个GIS引擎都会内置这一部分功能，而不是让开发者自己实现。 在交互方式上，几乎都是约定俗成的，比如用鼠标左键双击地图可以放大地图，按住鼠标左键拖动地图可以移动浏览地图，用滚动鼠标中间的滑轮可以放大缩小地图等等。 OpenLayers 3都内置支持这些交互方式，同时还具备更多的其他交互方式，这些都将一并在本章节介绍。 更为重要的是，了解其中的基本原理，并在此基础上，应用于自己的业务开发。 内置交互方式介绍OpenLayers 3提供了最基本的地图放大，缩小，平移等功能，以满足用户浏览地图的需要。 这些功能都是内置的，实现类都放在包ol.interaction下面，可以通过官网API查询到。 在做二次开发的时候，我们无需做任何设置，地图就具有这些功能，比如下面这个最简单的地图，你可以用鼠标对它进行浏览，不管是放大，还是缩小，平移都可以。 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 这个地图的代码在本教程最开始的时候，就已经见过了：12345678910111213141516&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; 虽然代码中没有做任何的设置，ol.Map的默认行为中，设置了和地图的交互方式，如果表示出来，代码是这样的：1234567891011121314151617&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; interactions: ol.interaction.defaults(), // 不设置的情况下，默认会设置为ol.interaction.defaults() layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; ol.interaction.defaults()这个函数用于返回默认的交互方式，通过API文档可知，还可以通过参数控制交互方式，非常的灵活。 在进一步深入之前，还是先了解一下默认都提供了那些交互方式： 按住alt+shift键，用鼠标左键拖动地图，就能让地图旋转，对应的交互类为ol.interaction.DragRotate。 用鼠标左键双击地图，就可以放大地图，对应的交互类为ol.interaction.DoubleClickZoom。 用鼠标左键，拖拽地图，就可以平移地图，对应的交互类为ol.interaction.DragPan。 在触摸屏上，用两个手指在触摸屏上旋转，就可以旋转地图，对应的交互类为ol.interaction.PinchRotate。 在触摸屏上，用两个手指在触摸屏上缩放，就可以缩放地图，对应的交互类为ol.interaction.PinchZoom。 用键盘上的上下左右键，就可以平移地图，对应的交互类为ol.interaction.KeyboardPan。 用键盘上的+/-键，就可以缩放地图，对应的交互类为ol.interaction.KeyboardZoom。 滚动鼠标中间的滑轮，就可以缩放地图，对应的交互类为ol.interaction.MouseWheelZoom。 按住shift键，同时用鼠标左键在地图上拖动，就可以放大地图，对应的交互类为ol.interaction.DragZoom。 从上面可以看到，支持的交互方式挺多的，归纳为缩放，平移，旋转三类。 同时支持键盘，鼠标，和触屏三种方式。 虽然默认的交互方式很全，但如果我们的地图只是在PC端提供或者只是在触屏提供，那么有些交互方式就会显得多余，最好是去掉不需要的，或者我们的地图因为业务需要，不允许用户平移，或者缩放地图。 为了满足这样的需求，ol.interaction.defaults()提供了相应的参数来控制交互方式，详见ol.interaction.defaults API文档。 下面简单演示一个不能缩放的地图： new ol.Map({ interactions: ol.interaction.defaults({ doubleClickZoom: false, mouseWheelZoom: false, shiftDragZoom: false, pinchZoom:false }), layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 代码如下：1234567891011121314151617181920212223&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; new ol.Map(&#123; // 让所有的zoom开关都设置为false interactions: ol.interaction.defaults(&#123; doubleClickZoom: false, mouseWheelZoom: false, shiftDragZoom: false, pinchZoom:false &#125;), layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; 有时候也需要设置地图不能旋转，只要设置altShiftDragRotate:false, pinchRotate:false即可，可自行验证。 注意事项细心的读者有可能已经发现了，前面的第一个地图，我们并没有做任何的限制，但是用键盘控制鼠标平移和缩放，是不行的。 原因在于地图使用的target获取不到键盘事件，我们需要做个简单的设置才行： new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map3', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); 代码如下： 1234567891011121314151617&lt;!--注意：需要设置tabindex，才能使div获得键盘事件--&gt;&lt;div id=\"map3\" tabindex=\"0\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map3', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;);&lt;/script&gt; 实现原理不管是上一节中的哪一种交互方式，本质上都是通过监听事件，来处理相应的业务的，在ol.Map的实现代码中，有下面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @private * @type &#123;ol.MapBrowserEventHandler&#125; */ this.mapBrowserEventHandler_ = new ol.MapBrowserEventHandler(this); for (var key in ol.MapBrowserEvent.EventType) &#123; // 遍历所有的事件类型 ol.events.listen(this.mapBrowserEventHandler_, ol.MapBrowserEvent.EventType[key], this.handleMapBrowserEvent, this); // 监听事件，函数handleMapBrowserEvent为事件响应函数 &#125; ...... /** * @param &#123;ol.MapBrowserEvent&#125; mapBrowserEvent The event to handle. */ol.Map.prototype.handleMapBrowserEvent = function(mapBrowserEvent) &#123; if (!this.frameState_) &#123; // With no view defined, we cannot translate pixels into geographical // coordinates so interactions cannot be used. return; &#125; this.focus_ = mapBrowserEvent.coordinate; mapBrowserEvent.frameState = this.frameState_; var interactions = this.getInteractions(); goog.asserts.assert(interactions !== undefined, 'interactions should be defined'); var interactionsArray = interactions.getArray(); var i; if (this.dispatchEvent(mapBrowserEvent) !== false) &#123; // 注意：如果事件处理返回false，交互类就不起作用了 for (i = interactionsArray.length - 1; i &gt;= 0; i--) &#123; // 遍历所有的交互方式 var interaction = interactionsArray[i]; if (!interaction.getActive()) &#123; continue; &#125; var cont = interaction.handleEvent(mapBrowserEvent); // 让各个交互类处理响应的事件 if (!cont) &#123; break; &#125; &#125; &#125;&#125;; 至于每一个交互类如何处理，就和业务相关了，再此之前，先看一下具体有哪些事件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Constants for event names. * @enum &#123;string&#125; */ol.MapBrowserEvent.EventType = &#123; /** * A true single click with no dragging and no double click. Note that this * event is delayed by 250 ms to ensure that it is not a double click. * @event ol.MapBrowserEvent#singleclick * @api stable */ SINGLECLICK: 'singleclick', /** * A click with no dragging. A double click will fire two of this. * @event ol.MapBrowserEvent#click * @api stable */ CLICK: ol.events.EventType.CLICK, /** * A true double click, with no dragging. * @event ol.MapBrowserEvent#dblclick * @api stable */ DBLCLICK: ol.events.EventType.DBLCLICK, /** * Triggered when a pointer is dragged. * @event ol.MapBrowserEvent#pointerdrag * @api */ POINTERDRAG: 'pointerdrag', /** * Triggered when a pointer is moved. Note that on touch devices this is * triggered when the map is panned, so is not the same as mousemove. * @event ol.MapBrowserEvent#pointermove * @api stable */ POINTERMOVE: 'pointermove', POINTERDOWN: 'pointerdown', POINTERUP: 'pointerup', POINTEROVER: 'pointerover', POINTEROUT: 'pointerout', POINTERENTER: 'pointerenter', POINTERLEAVE: 'pointerleave', POINTERCANCEL: 'pointercancel'&#125;; 这些事件在ol.Map的API文档里面，有些是能看到的，就是注释里面有@api的部分，其他的是暂时内部使用的。 按照这个逻辑，我们也可以实现自己的交互方式。 但有一点需要注意，ol.Map处理事件是有先后顺序的，注意看最前面的那段代码的注释，ol.Map会先派发事件给自己的监听器，然后才会把事件给interaction类处理。 如果前面的事件监听器返回false，那么后面的交互类就不会起作用。 比如像下面这样，用鼠标左键双击地图，并不能放大地图： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); map.on('dblclick', function(event){ return false; }); 为什么？ 注意看代码：123456789101112131415161718192021&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 监听了dblclick事件，并返回了false map.on('dblclick', function(event)&#123; return false; &#125;);&lt;/script&gt; 这样做了后，后果非常的严重，出问题后，可能还不知道为什么？ 所以建议不要轻易在MapBrowserEvent事件的监听器里面返回false。 到此，我们可以进一步分析一下ol.interaction相关交互类的内部实现了，以ol.interaction.DoubleClickZoom为例，其核心必然是处理事件： 12345678910111213141516ol.interaction.DoubleClickZoom.handleEvent = function(mapBrowserEvent) &#123; var stopEvent = false; var browserEvent = mapBrowserEvent.originalEvent; if (mapBrowserEvent.type == ol.MapBrowserEvent.EventType.DBLCLICK) &#123; // 事件类型过滤 var map = mapBrowserEvent.map; var anchor = mapBrowserEvent.coordinate; var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_; // 按住shift键，就缩小，否则就放大 var view = map.getView(); goog.asserts.assert(view, 'map must have a view'); ol.interaction.Interaction.zoomByDelta( map, view, delta, anchor, this.duration_); // 调用 ol.interaction.Interaction.zoomByDelta函数实现放大缩小 mapBrowserEvent.preventDefault(); stopEvent = true; &#125; return !stopEvent;&#125;; 代码其实很简单，如果要自己实现一种交互方式，对照ol.interaction.DoubleClickZoom这个学习，再加以应用就可以了。 Feature选取之选中样式OpenLayers 3除了在地图浏览方面提供内置的交互方式之外，还提供了地图上Feature选取的交互类： ol.interaction.Select。 这是一个经常会用到的类，应用范围非常的广。 我们可以先简单操作一下下面地图中的圆，点击一下，颜色就变了： var layer = new ol.layer.Vector({ source: new ol.source.Vector() }); var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 在地图上添加一个圆 var circle = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }) circle.setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'red' }) }) })); layer.getSource().addFeature(circle); // 添加一个用于选择Feature的交互方式 var selectSingleClick = new ol.interaction.Select({ // style: new ol.style.Style({ // image: new ol.style.Circle({ // radius: 10, // fill: new ol.style.Fill({ // color: 'blue' // }) // }) // }) }); map.addInteraction(selectSingleClick); selectSingleClick.on('select', function(event){ event.selected[0].setStyle(new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) })); }) 在自定义事件及应用中，我们用了方法map.forEachFeatureAtPixel来获取当前选择的Feature，这个例子中，我们没有这样使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector() &#125;); var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在地图上添加一个圆 var circle = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;) circle.setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;)); layer.getSource().addFeature(circle); // 前面的代码我们已经看了很多遍了，关键是下面这段代码 // 添加一个用于选择Feature的交互方式 var selectSingleClick = new ol.interaction.Select(&#123; // API文档里面有说明，可以设置style参数，用来设置选中后的样式，但是这个地方我们注释掉不用，因为就算不注释，也没作用，为什么？ // style: new ol.style.Style(&#123; // image: new ol.style.Circle(&#123; // radius: 10, // fill: new ol.style.Fill(&#123; // color: 'blue' // &#125;) // &#125;) // &#125;) &#125;); map.addInteraction(selectSingleClick); // 监听选中事件，然后在事件处理函数中改变被选中的`feature`的样式 selectSingleClick.on('select', function(event)&#123; event.selected[0].setStyle(new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;)); &#125;)&lt;/script&gt; 官网其实有例子select-features，但是这里面还是有一些需要注意的地方，比如上面注释里面说到的，为什么style参数设置了没用？ 因为我们的circle本身就设置了样式，而style参数设置的样式，其实是设置在内部新建的一个layer上的，而OpenLayers 3中，feature的样式优先级是大于layer的样式的优先级的。所以没生效，如果换成下面这种方式，就可以了： var layer2 = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'red' }) }) }) }); var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer2 ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 在地图上添加一个圆 var circle2 = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }) layer2.getSource().addFeature(circle2); // 添加一个用于选择Feature的交互方式 map2.addInteraction(new ol.interaction.Select({ style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) }) })); 代码变成这样了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer2 = new ol.layer.Vector(&#123; source: new ol.source.Vector(), // 注意：把feature上的style，直接移到layer上，避免直接在feature上设置style style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;) &#125;); var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer2 ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在地图上添加一个圆 var circle2 = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;) // 此处不再为feature设置style layer2.getSource().addFeature(circle2); // 添加一个用于选择Feature的交互方式 map2.addInteraction(new ol.interaction.Select(&#123; // 设置选中后的style style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;) &#125;));&lt;/script&gt; 代码改成上面这样就可以了。在使用过程中，请千万留意这个问题。 Feature选取之条件过滤涉及到选取，自然会有各种条件用于过滤，比如是鼠标左键单击，还是双击，是可以选取地图上的任意feature，还是某一类的feature。 对于这些需求，ol.interaction.Select都能满足，在API的文档里面就有相关的参数设置，下面就是一些简单的使用示例。 改变默认的单击选取方式默认情况下，是支持鼠标左键单击选取feature的，在地图上其他地方点击一下，就取消选取了，但这并不是定死的选取方式，你完全可以自定义。 比如鼠标移动到feature上，就选取了，试试： var layer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'red' }) }) }) }); var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 在地图上添加一个圆 var circle = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }) layer.getSource().addFeature(circle); // 添加一个用于选择Feature的交互方式 map.addInteraction(new ol.interaction.Select({ condition: ol.events.condition.pointerMove, // 唯一的不同之处，设置鼠标移到feature上就选取 style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) }) })); 代码同之前的例子只有一个地方不同： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;) &#125;); var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在地图上添加一个圆 var circle = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;) layer.getSource().addFeature(circle); // 添加一个用于选择Feature的交互方式 map.addInteraction(new ol.interaction.Select(&#123; condition: ol.events.condition.pointerMove, // 唯一的不同之处，设置鼠标移到feature上就选取 style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;) &#125;));&lt;/script&gt; ol.events.condition里面有很多内置的条件过滤函数，可以在官网API查询，如果内置方式没有，也可以自己写一个类似的函数，比如： 123ol.events.condition.singleClick = function(mapBrowserEvent) &#123; return mapBrowserEvent.type == ol.MapBrowserEvent.EventType.SINGLECLICK;&#125;; 就只是一个类型判断而已，是否非常的简单，任何人都可以自定义一个这种条件过滤函数。 直接对feature过滤除了可以自定义选取的交互方式之外，我们还可以对feature进行过滤，如果当前选取的并不是我们需要的feature，我们可以决定不选取。 比如我们只希望用户能选取圆形，而不能选取五星，选取方式为默认的单击： var circleLayer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'red' }) }) }) }); var starLayer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ image: new ol.style.RegularShape({ points: 5, radius1: 20, radius2: 10, fill: new ol.style.Fill({ color: 'red' }) }) }) }); var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), circleLayer, starLayer ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 在地图上添加一个圆 var circle1 = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }) circleLayer.getSource().addFeature(circle1); // 在地图上添加一个五星 var star = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104.06, 30.05], 'EPSG:4326', 'EPSG:3857')) }) starLayer.getSource().addFeature(star); // 添加一个用于选择Feature的交互方式 map2.addInteraction(new ol.interaction.Select({ style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) }), filter: function(feature, layer){ return layer === circleLayer; } })); 代码其实也是非常简单，前面大部分代码都是一样的，关键在最后： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 创建一个用于存放circle的layer var circleLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;) &#125;); // 创建一个用于存放star的layer var starLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; image: new ol.style.RegularShape(&#123; points: 5, radius1: 20, radius2: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;) &#125;); var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), circleLayer, starLayer ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在地图上添加一个圆 var circle1 = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;) circleLayer.getSource().addFeature(circle1); // 在地图上添加一个五星 var star = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104.06, 30.05], 'EPSG:4326', 'EPSG:3857')) &#125;) starLayer.getSource().addFeature(star); // 添加一个用于选择Feature的交互方式 map2.addInteraction(new ol.interaction.Select(&#123; style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;), // 关键： 设置过了条件，可以用feature来写过滤，也可以用layer来写过滤 filter: function(feature, layer)&#123; return layer === circleLayer; &#125; &#125;));&lt;/script&gt; 选取多个feature前面的例子都只是一个feature的情况，在实际应用中，肯定是不止一个的，如果要能同时选择多个，只需要设置一下构造函数的参数multi: true，默认情况下，只能选取一个feature。 仿照上面的代码，可自行尝试。 Feature选取之取消选中 取消选中有两种方式， 一种是在界面上以交互的方式取消选中，一种是用代码的方式取消选中，下面就分别介绍一下 交互方式取消选中如果是采用的默认的方式选取feature，即使用鼠标左键单击feature就可选取。那么这种交互方式下，要取消选中，则只需要同样使用鼠标左键，在地图其他地方单击一下，就可取消选中。 可跳到要素选取之选中样式，在第一个地图上试试。 如果采用的是自定义的方式选取feature，那么要取消选中，交互方式还是一样的，只要目标不再是已选中的feature就行，就能取消选中。 比如要素选取之条件过滤中，采用了自定义的鼠标移入feature就可选中，要取消选中，只需要把鼠标移出feature即可。 代码方式取消选中点击地图下方的“取消选中”按钮，就可触发代码，取消circle的选中状态： var layer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'red' }) }) }) }); var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }), layer ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 在地图上添加一个圆 var circle = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) }) layer.getSource().addFeature(circle); // 添加一个用于选择Feature的交互方式 var clickSelect = new ol.interaction.Select({ style: new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'blue' }) }) }) }); map.addInteraction(clickSelect); // 取消选中 function unselectFeature() { clickSelect.getFeatures().clear(); // 下面这样也是可以取消选中的，根据情况选择 // map.removeInteraction(clickSelect); } 前面的代码都一样，关键在最后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;input type=\"button\" value=\"取消选中\" onclick=\"unselectFeature();\"&gt;&lt;/input&gt;&lt;script type=\"text/javascript\"&gt; var layer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'red' &#125;) &#125;) &#125;) &#125;); var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;), layer ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 在地图上添加一个圆 var circle = new ol.Feature(&#123; geometry: new ol.geom.Point(ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857')) &#125;) layer.getSource().addFeature(circle); // 添加一个用于选择Feature的交互方式 var clickSelect = new ol.interaction.Select(&#123; style: new ol.style.Style(&#123; image: new ol.style.Circle(&#123; radius: 10, fill: new ol.style.Fill(&#123; color: 'blue' &#125;) &#125;) &#125;) &#125;); map.addInteraction(clickSelect); // 取消选中 function unselectFeature() &#123; clickSelect.getFeatures().clear(); // 下面这样也是可以取消选中的，根据情况选择 // map.removeInteraction(clickSelect); &#125;&lt;/script&gt; 至此，地图上元素的选取相关的知识点都介绍完毕，希望能逐个掌握并融会贯通于实际应用中。 绘图除了内置了用于选取feature的类之外，OpenLayers 3还提供了用户绘图的类ol.interaction.Draw，支持绘制点，线，多边形，圆等绘制。 我们可以先看一下下面这个可以绘制一条线的例子，用鼠标左键单击地图，地图上就会出现待绘制线的起点，随后移动鼠标，就看到了线，再单击地图，就在这个线上添加了点，依次可以添加多个点，如果要完成线的绘制，在最后一个点处，再点击一下鼠标左键即可。 var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); map.addInteraction(new ol.interaction.Draw({ type: 'LineString' })); 代码如下： 123456789101112131415161718192021&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 添加绘图的交互类 map.addInteraction(new ol.interaction.Draw(&#123; type: 'LineString' // 设置绘制线 &#125;));&lt;/script&gt; 看起来非常的简单。 但貌似还不可用，因为不知道怎么保存起来，下面我们把绘制完的线保存起来： var map2 = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map2', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 添加一个绘制的线使用的layer var lineLayer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'red', size: 1 }) }) }) map2.addLayer(lineLayer); map2.addInteraction(new ol.interaction.Draw({ type: 'LineString', source: lineLayer.getSource() // 注意设置source，这样绘制好的线，就会添加到这个source里 })); 比上一个地图写的代码稍微多一点，关键的代码还是在最后： 123456789101112131415161718192021222324252627282930313233&lt;div id=\"map2\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map2 = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map2', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 添加一个绘制的线使用的layer var lineLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;) map2.addLayer(lineLayer); map2.addInteraction(new ol.interaction.Draw(&#123; type: 'LineString', source: lineLayer.getSource() // 注意设置source，这样绘制好的线，就会添加到这个source里 &#125;));&lt;/script&gt; 这样，在地图上绘制一条线的工作基本上算是完成了。 按照这个流程，修改ol.interaction.Draw的构造参数type的值为’Point’，’Polygon’,，’MultiPoint’，’MultiLineString’，’MultiPolygon’ 或者 ‘Circle’就可以添加点，多边形，多个点，多条线，多个多边形，及圆。 可以自行修改验证。 绘图进阶前面只是简单的绘制上了一条线，在实际业务中，可能还需要设置绘图时的样式，限制绘制的点的个数，获取绘制的图形的所有坐标等。 在上一节的基础上，以下面这个地图为例，再给大家介绍一下这些方面的更深入的应用。下面绘制这条线的点不能超过4个，在绘制时，样式会和前一节的样式不太一样，在地图上方，会显示当前绘制完的线的所有点的坐标。 当前绘制线的坐标： var map = new ol.Map({ layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ], target: 'map', view: new ol.View({ center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }) }); // 添加一个绘制的线使用的layer var lineLayer = new ol.layer.Vector({ source: new ol.source.Vector(), style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'red', size: 1 }) }) }) map.addLayer(lineLayer); var lineDraw = new ol.interaction.Draw({ type: 'LineString', source: lineLayer.getSource(), // 注意设置source，这样绘制好的线，就会添加到这个source里 style: new ol.style.Style({ stroke: new ol.style.Stroke({ color: '#009933', size: 1 }) }), maxPoints: 4 }); // 监听线绘制结束事件，获取坐标 lineDraw.on('drawend', function(event){ document.getElementById('points').innerHTML = JSON.stringify(event.feature.getGeometry().getCoordinates()); }); map.addInteraction(lineDraw); 代码如下，关键代码还是放在最后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div style=\"background-color: #999;\"&gt;&lt;span&gt;当前绘制线的坐标：&lt;/span&gt;&lt;span id='points'&gt;&lt;/span&gt;&lt;/div&gt;&lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123; source: new ol.source.OSM() &#125;) ], target: 'map', view: new ol.View(&#123; center: ol.proj.transform( [104, 30], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;) &#125;); // 添加一个绘制的线使用的layer var lineLayer = new ol.layer.Vector(&#123; source: new ol.source.Vector(), style: new ol.style.Style(&#123; stroke: new ol.style.Stroke(&#123; color: 'red', size: 1 &#125;) &#125;) &#125;) map.addLayer(lineLayer); var lineDraw = new ol.interaction.Draw(&#123; type: 'LineString', source: lineLayer.getSource(), // 注意设置source，这样绘制好的线，就会添加到这个source里 style: new ol.style.Style(&#123; // 设置绘制时的样式 stroke: new ol.style.Stroke(&#123; color: '#009933', size: 1 &#125;) &#125;), maxPoints: 4 // 限制不超过4个点 &#125;); // 监听线绘制结束事件，获取坐标 lineDraw.on('drawend', function(event)&#123; // event.feature 就是当前绘制完成的线的Feature document.getElementById('points').innerHTML = JSON.stringify(event.feature.getGeometry().getCoordinates()); &#125;); map.addInteraction(lineDraw);&lt;/script&gt; 如果需要取消当前绘制，直接用map.removeInteraction(lineDraw)就可以了。 总结交互实现流程从地图浏览的交互类，到feature选取的类，再到绘制图形的类，都是从事件入手，在引擎内部，提供了一个事件传递的通道，支持通过ol.Map添加interaction的方式，接收事件消息，然后再根据业务进行处理。 封装的优点和缺点毫无疑问，已经内置实现的功能，将极大地提高系统可用性，减少开发者的负担。 但内置的这些通用功能，如果是简单的封装，并不能满足大多数的需要，但是过多的封装，将增大复杂性，比如很多interaction类都有很多的参数设置，必然增加学习和使用成本，这就是缺点。 对于一般的开发者而言，没有能力自己重新定制开发交互方式，那么最好是学会内置类的应用，虽然有学习成本，但能保证功能没有问题。对于高阶开发者而言，可选择性就很多了，如果效率不行或者流程太复杂，就自己开发。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"OpenLayers 3 View","date":"2018-01-18T12:29:59.000Z","path":"20180118/openlayers/ch04/index.html","text":"View所见即所得是大家喜闻乐见的，View就是这样的，作为地图的窗口，做一些改变，就能看到变化，便于初学者学习。同时，View是OpenLayers 3地图组成部分中非常重要的一个概念，涉及到地图移动，放大，缩小，旋转等，这些功能是任何一个GIS引擎必不可少的。为此，我们把它作为最先介绍和学习的组成部分。 地图导航在深入学习之前，还是先来个开胃菜，见识一下View所承载的功能。下面将演示地图导航功能，关于导航相关功能，在前面操作地图的时候，已经有了充分的理解和认识。为什么我们还要再讨论它呢？因为这次的导航功能，需要自己来实现，而且只使用ol.View提供的方法就可以做到。 var map = new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ // 设置成都为地图中心，此处进行坐标转换， 把EPSG:4326的坐标，转换为EPSG:3857坐标，因为ol默认使用的是EPSG:3857坐标 // 请阅读“地图坐标系”了解更多坐标系的信息。 center: ol.proj.transform([104.06, 30.67], 'EPSG:4326', 'EPSG:3857'), zoom: 10 }), target: 'map' }); // 向左移动地图 function moveToLeft() { var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的x值增加，即可使得地图向左移动，增加的值根据效果可自由设定 mapCenter[0] += 50000; view.setCenter(mapCenter); map.render(); } // 向右移动地图 function moveToRight() { var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的x值减少，即可使得地图向右移动，减少的值根据效果可自由设定 mapCenter[0] -= 50000; view.setCenter(mapCenter); map.render(); } // 向上移动地图 function moveToUp() { var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的y值减少，即可使得地图向上移动，减少的值根据效果可自由设定 mapCenter[1] -= 50000; view.setCenter(mapCenter); map.render(); } // 向下移动地图 function moveToDown() { var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的y值增加，即可使得地图向下移动，增加的值根据效果可自由设定 mapCenter[1] += 50000; view.setCenter(mapCenter); map.render(); } // 移动到成都 function moveToChengDu() { var view = map.getView(); // 设置地图中心为成都的坐标，即可让地图移动到成都 view.setCenter(ol.proj.transform([104.06, 30.67], 'EPSG:4326', 'EPSG:3857')); map.render(); } // 放大地图 function zoomIn() { var view = map.getView(); // 让地图的zoom增加1，从而实现地图放大 view.setZoom(view.getZoom() + 1); } // 缩小地图 function zoomOut() { var view = map.getView(); // 让地图的zoom减小1，从而实现地图缩小 view.setZoom(view.getZoom() - 1); } 点击地图下方的几个按钮试试响应的功能，用它们就可以完整的实现地图导航了。按照惯例，下面我们会给出对应的源码，但我希望你能先学习一下ol.View的API文档，从中找出我们可能使用了的方法。 好了，下面就来揭晓答案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%, height: 400px\"&gt;&lt;/div&gt; &lt;div id=\"navigate-container\"&gt; &lt;input type=\"button\" onClick=\"moveToLeft();\" value=\"左移\" /&gt; &lt;input type=\"button\" onClick=\"moveToRight();\" value=\"右移\" /&gt; &lt;input type=\"button\" onClick=\"moveToUp();\" value=\"上移\" /&gt; &lt;input type=\"button\" onClick=\"moveToDown();\" value=\"下移\" /&gt; &lt;input type=\"button\" onClick=\"moveToChengDu();\" value=\"移到成都\" /&gt; &lt;input type=\"button\" onClick=\"zoomIn();\" value=\"放大\" /&gt; &lt;input type=\"button\" onClick=\"zoomOut();\" value=\"缩小\" /&gt; &lt;/div&gt; &lt;script&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; // 设置成都为地图中心，此处进行坐标转换， 把EPSG:4326的坐标，转换为EPSG:3857坐标，因为ol默认使用的是EPSG:3857坐标 center: ol.proj.transform([104.06, 30.67], 'EPSG:4326', 'EPSG:3857'), zoom: 10 &#125;), target: 'map' &#125;); // 向左移动地图 function moveToLeft() &#123; var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的x值增加，即可使得地图向左移动，增加的值根据效果可自由设定 mapCenter[0] += 50000; view.setCenter(mapCenter); map.render(); &#125; // 向右移动地图 function moveToRight() &#123; var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的x值减少，即可使得地图向右移动，减少的值根据效果可自由设定 mapCenter[0] -= 50000; view.setCenter(mapCenter); map.render(); &#125; // 向上移动地图 function moveToUp() &#123; var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的y值减少，即可使得地图向上移动，减少的值根据效果可自由设定 mapCenter[1] -= 50000; view.setCenter(mapCenter); map.render(); &#125; // 向下移动地图 function moveToDown() &#123; var view = map.getView(); var mapCenter = view.getCenter(); // 让地图中心的y值增加，即可使得地图向下移动，增加的值根据效果可自由设定 mapCenter[1] += 50000; view.setCenter(mapCenter); map.render(); &#125; // 移动到成都 function moveToChengDu() &#123; var view = map.getView(); // 设置地图中心为成都的坐标，即可让地图移动到成都 view.setCenter(ol.proj.transform([104.06, 30.67], 'EPSG:4326', 'EPSG:3857')); map.render(); &#125; // 放大地图 function zoomIn() &#123; var view = map.getView(); // 让地图的zoom增加1，从而实现地图放大 view.setZoom(view.getZoom() + 1); &#125; // 缩小地图 function zoomOut() &#123; var view = map.getView(); // 让地图的zoom减小1，从而实现地图缩小 view.setZoom(view.getZoom() - 1); &#125; &lt;/script&gt;&lt;/body&gt; 使用input标签增加了几个按钮，每个按钮都绑定了对应的点击事件监听，对应的监听函数实现了某一种导航的功能，都很简单，并且代码都有注释，容易理解。创建地图的代码几乎没有任何改变，也不过多说明，请结合代码和上面的地图进行理解。 在功能上，目前尚有两个方面的欠缺，一是按钮没有集成在地图上；二是移动并不平滑。这两部分功能缺失将在我们学习了Control和动画之后，一步一步再补充完善，此处暂时不深入下去。现在需要考虑的是我们在代码中使用了ol.proj.transform这个方法，它有什么作用？ 坐标是否已经知道ol.proj.transform的功能了？你应该知道的，因为有API文档。它主要用于坐标转换，它的第一个参数是ol.Coordinate类型的坐标，后面两个参数依次是当前坐标所用的坐标系，及转换后的坐标所用的坐标系，ol.proj.transform([104.06, 30.67], &#39;EPSG:4326&#39;, &#39;EPSG:3857&#39;)就能把EPSG:4326的坐标[104.06, 30.67]转换为EPSG:3857的坐标。 在了解这个函数的功能后，可能不禁会问：为什么要弄的如此复杂，是不是还有很多其他的坐标系？是的，确实存在很多其他的坐标系，如果可以选择的话，应该没人愿意这样。道理如同这个世界上存在各种各样的货币一样。在下一个小节，就会详细介绍多个坐标系及存在的原因。但在此之前，我们得先了解一个有意义的坐标应该如何定义。 如果单独地看[45.06, 30.67]，这是没有任何意义的两个数字，在不同的场景，不同的人眼里，它们可以是某个仪器的两个测量值，也可以是学生的考试成绩，还可以是某个坐标。大家或许已经意识到，场景是非常重要的，假如我们定义这两个数字表示的是一个地理位置的坐标，那请问你知道这个坐标所指的具体位置吗？肯定是不能的。因为我们并不知道这个坐标里面的数字使用什么单位，是度？是米？还是其他的单位？如果添加上单位，也还不够，假设单位是度，我们还是不知道坐标中的前一个数字是经度，还是纬度。即使定义经纬度，也还不够，因为还有很多不确定的东西，比如这个坐标相对的原点在哪里？二维还是三维，哪个方向为正向？ 一个有意义的坐标并不是我们看上去那样简单，特别是地理坐标，但初学者往往会忽略这点，从而造成在应用中经常出现定位错误。 坐标系及投影关于原点，方向，单位等等的相关定义和描述，组成了我们常说的坐标系。谈到坐标系，就会想起初中数学中经常接触到的二维笛卡尔坐标系，在图形学中也会遇到三维坐标系，在GIS中我们需要地理坐标系。但它并不像笛卡尔坐标系那样简单，学过地理知识就知道，地球并不是一个完全规则的球体。在不同的地区，为了在数学上表示它，就出现了多种不同的参考椭球体，比如克拉索夫斯基(Krasovsky)椭球体，WGS1984椭球体，更多的椭球体参见参考椭球体。在参考椭球体的基础上，就发展出了不同的地理坐标系，比如我国常用的WGS84，北京54，西安80坐标系，欧洲，北美也有不同的坐标系。北京54使用的是克拉索夫斯基(Krasovsky)椭球体，WGS84使用的是WGS1984椭球体。由此可见，多个坐标系是源于地理的复杂性。 由于存在着多种坐标系，即使同样的坐标，在不同的坐标系中，也表示的是不同的位置，这就是大家经常遇到的偏移问题的根源，要解决这类问题，就需要纠偏，把一个坐标系的坐标转换成另一个坐标系的坐标。由于WGS84是全球通用的坐标系，涉及到多个坐标系与它之间的转换，所以在此做个简单的介绍。 WGS84，全称World Geodetic System 1984，是为GPS全球定位系统使用而建立的坐标系统。通过遍布世界的卫星观测站观测到的坐标建立，其初次WGS84的精度为1-2m，在1994年1月2日，通过10个观测站在GPS测量方法上改正，得到了WGS84（G730），G表示由GPS测量得到，730表示为GPS时间第730个周。 1996年，National Imagery and Mapping Agency (NIMA) 为美国国防部 (U.S.Department of Defense, DoD)做了一个新的坐标系统。这样实现了新的WGS版本WGS（G873）。其因为加入了美国海军天文台和北京站的改正，其东部方向加入了31-39cm 的改正。所有的其他坐标都有在1分米之内的修正。 关于北京54和西安80坐标系，请自行通过网络查找相关资料进行了解。 有了坐标系后，我们就能精确的表示地球上的每一个位置，但为什么还需要投影呢？投影是为了把不可展的椭球面描绘到平面上，它使用几何透视方法或数学分析的方法，将地球上的点和线投影到可展的曲面(平面、园柱面或圆锥面)上，再将此可展曲面展成平面，建立该平面上的点、线和地球椭球面上的点、线的对应关系。正是因为有投影，大家才能在网页上看到二维平面的地球地图。 投影方式也多种多样，其中有一种投影叫墨卡托投影(Mercator Projection)，广泛使用于网页地图，对于OpenLayers 3的开发者而言，尤其重要，详情参见墨卡托投影。 如果不了解上面这些基本知识，在使用OpenLayers 3的过程中，会感觉寸步难行，相反，则得心应手。 OpenLayers 3使用的坐标系目前OpenLayers 3支持两种投影，一个是EPSG:4326，等同于WGS84坐标系，参见详情。另一个是EPSG:3857，等同于900913，由Mercator投影而来，经常用于web地图，参见详情。一个是全球通用的，一个是web地图专用的，自然OpenLayers 3支持它们。在使用过程中，需要注意OpenLayers 3默认使用的是EPSG:3857。这也是为什么前面的代码里需要进行坐标转换的原因。 既然支持EPSG:4326，为什么还要转换？当然是可以不用转换的，但前提是你得指定使用具体那种投影，就像下面这样。 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 }), target: 'map' }); 代码很简单： 123456789101112131415161718&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;script&gt; new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], // 指定投影使用EPSG:4326 projection: 'EPSG:4326', zoom: 10 &#125;), target: 'map' &#125;); &lt;/script&gt;&lt;/body&gt; 所以开发时需要记住的是当前OpenLayers 3使用的坐标系及投影，以及我们自己的数据所使用的坐标系及投影。在没有弄清楚之前，就不要继续后面的内容学习，直到弄清楚为止。 ol.View的应用地图导航是View应用的一个例子，但仅限于导航。其实View还有一些其他的功能，在开发中经常遇到。比如控制地图显示范围，自动适配某个范围等等。若有所了解，可跳过本章节，直接进入下一个章节。 限制地图范围在实际使用中，往往只关心某一个区域的地图，而无需显示整个地球的地图，这样可以聚焦于业务，同时可以减少前端和后台的地图数据。无疑，这样的功能是非常有用的。下面我们就将看到，地图只能在经度29度到31度，纬度在102到104度之间显示。 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ extent: [102, 29, 104, 31], // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 }), target: 'map' }); 不妨上下左右拖拽地图试试，是否发现上下左右都存在着边界？其实代码很简单：12345678910111213141516171819&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;script&gt; new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; // 设置地图中心范围 extent: [102, 29, 104, 31], // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'map' &#125;); &lt;/script&gt;&lt;/body&gt; 就只是添加了 extent: [102, 29, 104, 31],这行代码就实现了功能。extent参数类型为[minX, minY, maxX, maxY]的ol.Extent，很容易记住。 如果对上面的地图进行缩小，然后再看地图，是否发现范围[102, 29, 104, 31]外的区域也显示出来了，而这并不是我们期望看到的。这时请注意仔细看extent参数的说明，这个范围指的是地图中心的限制范围，而不是整个地图显示的范围。那遇到这个问题该怎么办？我们发现，当我们地图放大后，这个问题并不那么明显，地图放大的越大，固定窗口显示的实际地理范围越小。一个简单的办法就是限制地图不能无限缩小，具体允许缩小到哪一级，可通过实际缩小地图到刚好填满整个窗口(id为map的div)来确定。限制地图缩放级别可参见下一节。 这是一种简单的做法，虽然有效，但并不精确，如果要做到非常精确，还需要学习后面更多的知识(分辨率等)，在后续章节会有更深入的说明和示例。 限制地图缩放级别有时无限制地允许用户缩小或者放大地图，并不是一种明智的做法，在地图上的feature、标注、图形等都会变的不便于查看。为此，适中的地图缩放级别是被大多数场景所需要的。下面演示地图你只能在10到14级进行缩放。 new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10, minZoom: 10, maxZoom: 14 }), target: 'map' }); 缩放试试便知，地图现在不能无限缩小放大了，代码也是非常的简单： 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;script&gt; new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10, // 限制地图缩放最大级别为14，最小级别为10 minZoom: 10, maxZoom: 14 &#125;), target: 'map' &#125;); &lt;/script&gt;&lt;/body&gt; 很多初学者问这个问题，其实仔细阅读一下API文档就会知道如何编码，以至于很多已经知道这个功能的其他开发者不愿意回答这么基础的功能。如果只是显示最小级别则只用设置minZoom的值即可，反之只设置maxZoom的值。 除了使用minZoom和maxZoom之外，还可以使用minResolution和maxResolution，其具体原理和使用，在分辨率小节会有介绍。对于开发者而言，建议使用minZoom和maxZoom，简单直接。 自适配区域在实际应用中，会有一些地图查找和标注的业务，比如查看成都市锦江区。而这时，地图所在区域可能是北京，我们需要能够让地图直接定位到锦江区，并且最大化完全地显示这块区域。下面就将演示这个功能。 var map = new ol.Map({ layers: [ new ol.layer.Tile({source: new ol.source.OSM()}) ], view: new ol.View({ // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 }), target: 'map' }); function fitToChengdu() { // 让地图最大化完全地显示区域[104, 30.6, 104.12, 30.74] map.getView().fit([104, 30.6, 104.12, 30.74], map.getSize()); } 点击地图下方的按钮显示成都，看看有什么效果。代码如下： 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=\"map\" style=\"width: 100%\"&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"显示成都\" onclick=\"fitToChengdu();\" /&gt; &lt;script&gt; var map = new ol.Map(&#123; layers: [ new ol.layer.Tile(&#123;source: new ol.source.OSM()&#125;) ], view: new ol.View(&#123; // 设置成都为地图中心 center: [104.06, 30.67], projection: 'EPSG:4326', zoom: 10 &#125;), target: 'map' &#125;); function fitToChengdu() &#123; // 让地图最大化完全地显示区域[104, 30.6, 104.12, 30.74] map.getView().fit([104, 30.6, 104.12, 30.74], map.getSize()); &#125; &lt;/script&gt;&lt;/body&gt; 只用了一行代码，ol.View的fit函数很强大，希望初学者能认真仔细的查看API文档，它的第三个参数还可以设置更多的选项，以适应更多的需要。关于更多的使用，参见官网例子Advanced View Positioning。","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"openlayers","date":"2018-01-18T12:00:31.000Z","path":"20180118/openlayers/index.html","text":"OpenLayers 3 Primer介绍由于在学习OpenLayers3，有缘看到OpenLayers 3 Primer教程，真是很荣幸。转到博客，仅仅方便地铁上阅读，学习。这是一个关于OpenLayers 3使用的入门教程。帮助初学者逐步认识OpenLayers 3，理解地图组成，以及各个组成部分的作用。在此基础上，逐个突破，结合大量的实例，指导大家应用OpenLayers 3开发出符合业务的地图。在这个过程中，辅以对应的理论知识，学习了解OpenLayers 3背后的原理，尽量做到知其然且知其所以然，为更高级的OpenLayers 3开发打下坚实的基础。本教程将坚持实用为主，对应用中遇到的重点、难点加以详细讲解，提出实用方案。 为了满足广大初学者的需要，教程将坚持一个原则：即以浅显易懂为基础，以有效实用为最终目标的原则。 为什么要写这样一个教程故事是从我学习OpenLayers 3开始的。那时版本才3.0.0，当时学习OpenLayers 3很快就入手了，没有遇到任何障碍。 但后来发现有些初学者并不是这样的，都不知道怎么入手，遇到很多问题，我在回答了很多类似问题后，开始寻找入门难的原因。 总结下来有两个主要原因： 第一，虽然官网有关于每个类和方法的API文档，也有相关的例子，但就是没有一个系统的教程把他们串起来，对着例子虽然能做出一些类似的业务，但并不能灵活应用，自然会遇到很多问题。 同时国内目前并没有一本关于OpenLayers 3学习的书籍或教程，这是比较让人遗憾的事。庆幸地是国外的同仁已经写了两本英文书籍，一本是OpenLayers 3: Beginner’s Guide，需要付费；另一本是The book of OpenLayers 3，需要付费，但同时也支持开放。但对于国内开发者而言，还是中文更加可读。 (国外最近又出了两本需要付费的书，一本是Mastering Openlayers 3，这本书内容涵盖也比较全面，对英文没有障碍的初学者，可以学习。 另一本是OpenLayers 3.x Cookbook - Second Edition) 第二，使用OpenLayers 3的初学者并不都是GIS专业出身，有很大一部分是前端开发者，或者其他领域的开发者，GIS相关的理论知识欠缺。同时，还有一些开发者连JavaScript语言也不熟练，API文档都不知道如何阅读。 但由于任务或者项目压身，不得不使用Openlayers开发，自然会遇到很多困难。 为了解决这个问题，我写过一篇OpenLayers 3 入门指南，一开始想当然地认为可以解决入门问题，直到有一天在群里来了一个初学者，他看了这篇文章后，觉得并没有什么卵用。这时我才意识到问题的严重性，问题没解决，反而多了一篇垃圾。因为入门者需要的是更为具体的东西。 在征集了大多数人的意见后，我决定写这本教程（在此一并感谢QQ群里那些提出意见，给予帮助的帅哥美女们）。目前国内存在很多OpenLayers 3的爱好者和使用者，我所在的QQ群就有将近千人，同时还存在很多其他关于OpenLayers的群，后续还会有更多的开发者使用它。 本教程作为一次尝试，我愿意做第一本国内的OpenLayers 3教程，希望能在开放的情况下，真正帮助到国内OpenLayers 3的初学者入门，虽然这并不容易，但我愿意挑战自己，并加入到开源的潮流中去，以此向OpenLayers 3这个优秀的开源引擎致敬，向它的开发团队和所有贡献者致敬！ 目标读者本教程的主要目标读者是刚开始接触OpenLayers 3的应用开发者，但对它有一定了解的开发者也可以通过这个教程的后续部分来提升自己的理解和认识。同时希望对它有深入了解的开发者review本教程，提交issue或者PR。 环境 OpenLayers 3的版本: 3.13.1 浏览器: chrome 47.0.2526.111(64bit) 关于环境，这边可能会使用openlayers 3或者4来实验和学习。关于作者QQ群 OpenLayers官方旗舰群[2] 里面的 扯淡大叔QQ: 11364382 BTW我和一帮天南海北的朋友们正在开发一个开源的WEB 3D GIS引擎F3Earth，有兴趣的朋友可以了解一下，谢谢大家的支持。 Summary OpenLayers 3 介绍 一个简单的地图 OpenLayers 3地图 初步解析地图组成 地图所有组成部分 看懂API 结合API文档分析代码 ol.Map的应用 定制地图logo 单页面多地图 地图联动 动态交换地图 View 地图导航 坐标 坐标系及投影 OpenLayers 3使用的坐标系 ol.View的应用 限制地图范围 限制地图缩放级别 自适配区域 Source和Layer 加载瓦片地图 最简单的加载在线地图 万能瓦片地图加载秘籍 加载离线瓦片地图 瓦片加载的源码浅析与小结 静态地图及应用 加载WMS服务地图 矢量地图 获取加载后的所有feature 坐标转换 样式设置 图层叠加及管理 LOD与分辨率 LOD原理 瓦片计算 分辨率 自定义瓦片地图及加载 图标及提示信息 应用overlay 动画图标 style及应用 设置图标位置 根据层级放大缩小图标 另类设置svg图标 规则几何体图标 用Canvas自绘图标 动态改变图标 文字标注 styleFunction应用 大量图标方案 提示信息 事件 一个简单的事件应用 注销事件响应 常用事件 自定义事件及应用 Interaction 内置交互方式介绍 实现原理 Feature选取之选中样式 Feature选取之条件过滤 Feature选取之取消选中 绘制一条线 绘图进阶 总结 Control 控件概览 探究控件原理 控件美颜 自定义控件 动画 动画简单应用 动画高阶应用 利用postcompose事件做动画 进阶实例 通过wfs增删改查要素 GeoServer环境配置 配置数据源 通过wfs查询要素 通过wfs修改要素 通过wfs添加要素 通过wfs删除要素 常见问题 注意事项","tags":[{"name":"openLayers","slug":"openLayers","permalink":"https://jiangshaobo.cn/tags/openLayers/"}]},{"title":"Tomcat运行一段时间后报错cache eviction process was unable to free [10]","date":"2018-01-18T09:50:25.000Z","path":"20180118/Tomcat运行一段时间后报错cache-eviction-process-was-unable-to-free.html","text":"应用运行一段时间后崩掉了。查看日志记录如下:123456789101112131415161718192015-Jan-2018 16:56:55.801 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.webresources.Cache.backgroundProcess The background cache eviction process was unable to free [10] percent of the cache for Context [] - consider increasing the maximum size of the cache. After eviction approximately [24,460] KB of data remained in the cache.15-Jan-2018 16:57:05.810 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.webresources.Cache.backgroundProcess The background cache eviction process was unable to free [10] percent of the cache for Context [] - consider increasing the maximum size of the cache. After eviction approximately [24,460] KB of data remained in the cache.15-Jan-2018 16:57:15.819 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.webresources.Cache.backgroundProcess The background cache eviction process was unable to free [10] percent of the cache for Context [] - consider increasing the maximum size of the cache. After eviction approximately [24,460] KB of data remained in the cache.15-Jan-2018 16:57:25.827 INFO [ContainerBackgroundProcessor[StandardEngine[Catalina]]] org.apache.catalina.webresources.Cache.backgroundProcess The background cache eviction process was unable to free [10] percent of the cache for Context [] - consider increasing the maximum size of the cache. After eviction approximately [24,460] KB of data remained in the cache. 日志中记录并给出了建议：1consider increasing the maximum size of the cache 也就是增加最大缓存。 打开tomcat下的conf文件下(tomcat_home/conf/Catalina/localhost/里的context文件里)的context.xml在文件尾部前增加添加这么一行：1&lt;Resources cachingAllowed=\"true\" cacheMaxSize=\"100000\" /&gt; 把cacheMaxSize调大就行了。 群友说可能是代码的问题，正在排查中。最后来个群友发的段子。 1234我今天突然觉得递归可以这样通俗的表达出来：两个人玩成语接龙，第一个人说：为所欲为。第二个人说：为所欲为。......","tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://jiangshaobo.cn/tags/tomcat/"}]},{"title":"win10安装Postgresql 错误解决方案 Failed to load sql modules into the","date":"2018-01-14T08:28:57.000Z","path":"20180114/win10安装Postgresql-错误解决方案-Failed-to-load-sql-modules-into-the.html","text":"win10安装postgrelsql安装了很多次都是报错，开始查明以为是权限的问题，然后就给文件夹赋予权限，以为快解决了，又出现了 Failed to load sql modules into the database cluster的错误，于是根据错误去继续寻找解决方案，ubuntu下分分钟就install了。最后翻看stackoverflow找到解决方案。步骤如下：I was getting this same error when trying to install PostgreSQL v9.4.4 on Windows 10 Pro. Starting with a solution hosted on Stack Exchange, I came up with the following steps that allowed the installer to run successfully: 1234567891) Create a new user account, called postgres2) Add the new account to the Administrators and Power Users groups3) Restart the computer NOTE: I added step #3, since step #4 didn't work without it4) Run a command prompt as the postgres user, using the command: runas /user:postgres cmd.exe5) Run the installer from the postgres command window6) Delete the postgres user account, as well as the user directory NOTE: I added step #6, since the postgres account is not required after installation 第二步的话，在win10下很简单，在此电脑（我的电脑）下右键选管理，右键-》新增用户（postgres），然后重启用原来的用户登陆。注意第四步，可以按win+r打开运行命令，然后输入1runas /user:postgres cmd.exe 之后在cmd里面直接运行postgresql-10.1-3-windows-x64.exe，安装成功。win10安装Postgresql 错误解决方案 Failed to load sql modules into the database clusterwin10安装Postgresql 错误解决方案 新增用户 建议访问：stackoverflow","tags":[{"name":"postgresql","slug":"postgresql","permalink":"https://jiangshaobo.cn/tags/postgresql/"},{"name":"win10","slug":"win10","permalink":"https://jiangshaobo.cn/tags/win10/"},{"name":"fail","slug":"fail","permalink":"https://jiangshaobo.cn/tags/fail/"}]},{"title":"centos ubuntu下安装nodejs环境","date":"2018-01-13T09:33:18.000Z","path":"20180113/centos-ubuntu下安装nodejs环境.html","text":"申请了阿里云的主机，后续打算将博客转移到阿里云上，之前的腾讯云由于没有备案都闲置了，用作测试。顺便从头记录node学习相关。 先安装一个node环境，到node官网下载node安装包1https://nodejs.org/zh-cn/download/ 1https://nodejs.org/dist/v8.9.3/node-v8.9.3-linux-x64.tar.xz centos ubuntu下安装nodejs环境 由于是新的环境，一切都是新的。 首先cd到/temp下，wget https://nodejs.org/dist/v8.9.3/node-v8.9.3-linux-x64.tar.xz 然后解压node-v8.9.3-linux-x64.tar.xz文件(默认使用的root用户，非root用户命令前加sudo)。 123xvf -d node-v8.9.3-linux-x64.tar.xzmv node-v8.9.3-linux-x64 nodecp -R node /usr/local 将node-v8.9.3-linux-x64重新命名为node 再把node复制到/usr/local下。 之后配置环境变量，由于没有安装vim，先使用vi来编辑， 1vi /etc/profile 在/etc/profile下追加node环境配置 123export NODE_HOME=/usr/local/nodeexport PATH=$NODE_HOME/bin:$PATHexport NODE_PATH=$NODE_HOME/lib/node_modules:$PATH 然后按esc之后输入:wq（保存并退出） 让配置生效source /etc/profile 这样安装完成。可以使用node -v查看node版本，可以使用npm -v查看npm版本 安装cnpm或者换源。 如果在centos下（ubuntu也是类似，只是命令不一样）要编译安装node首先 1yum -y install gcc make gcc-c++ openssl-devel wget 下载源码 1wget https://nodejs.org/dist/v8.9.3/node-v8.9.3.tar.gz 解压1tar -zxvf node-v8.9.3-linux-x64.tar.gz 编译安装 12./configuremake &amp;&amp; make install 然后验证 1node -v 安装pm21https://github.com/Unitech/pm2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# General$ npm install pm2 -g # Install PM2$ pm2 start app.js # Start, Daemonize and auto-restart application (Node)$ pm2 start app.py # Start, Daemonize and auto-restart application (Python)$ pm2 start npm -- start # Start, Daemonize and auto-restart Node application# Cluster Mode (Node.js only)$ pm2 start app.js -i 4 # Start 4 instances of application in cluster mode # it will load balance network queries to each app$ pm2 reload all # Zero Second Downtime Reload$ pm2 scale [app-name] 10 # Scale Cluster app to 10 process# Process Monitoring$ pm2 list # List all processes started with PM2$ pm2 monit # Display memory and cpu usage of each app$ pm2 show [app-name] # Show all information about application# Log management$ pm2 logs # Display logs of all apps$ pm2 logs [app-name] # Display logs for a specific app$ pm2 logs --json # Logs in JSON format$ pm2 flush$ pm2 reloadLogs# Process State Management$ pm2 start app.js --name=\"api\" # Start application and name it \"api\"$ pm2 start app.js -- -a 34 # Start app and pass option \"-a 34\" as argument$ pm2 start app.js --watch # Restart application on file change$ pm2 start script.sh # Start bash script$ pm2 start app.json # Start all applications declared in app.json$ pm2 reset [app-name] # Reset all counters$ pm2 stop all # Stop all apps$ pm2 stop 0 # Stop process with id 0$ pm2 restart all # Restart all apps$ pm2 gracefulReload all # Gracefully reload all apps in cluster mode$ pm2 delete all # Kill and delete all apps$ pm2 delete 0 # Delete app with id 0# Startup/Boot management$ pm2 startup # Detect init system, generate and configure pm2 boot on startup$ pm2 save # Save current process list$ pm2 resurrect # Restore previously saved processes$ pm2 unstartup # Disable and remove startup system$ pm2 update # Save processes, kill PM2 and restore processes$ pm2 generate # Generate a sample json configuration file# Deployment$ pm2 deploy app.json prod setup # Setup \"prod\" remote server$ pm2 deploy app.json prod # Update \"prod\" remote server$ pm2 deploy app.json prod revert 2 # Revert \"prod\" remote server by 2# Module system$ pm2 module:generate [name] # Generate sample module with name [name]$ pm2 install pm2-logrotate # Install module (here a log rotation system)$ pm2 uninstall pm2-logrotate # Uninstall module$ pm2 publish # Increment version, git push and npm publish","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://jiangshaobo.cn/tags/nodejs/"},{"name":"node.js","slug":"node-js","permalink":"https://jiangshaobo.cn/tags/node-js/"},{"name":"centos","slug":"centos","permalink":"https://jiangshaobo.cn/tags/centos/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://jiangshaobo.cn/tags/ubuntu/"}]},{"title":"Hello World Hexo 命令笔记","date":"2018-01-12T16:18:25.772Z","path":"20180113/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Hexo简写12345hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的1234hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿1hexo publish [layout] &lt;title&gt; 模版123456789hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo \"My Gallery\"hexo new \"Hello World\" --lang tw 变量 描述12345678910111213layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2018-01-14 23:18:00comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo \"My Gallery\" 变量 描述layout 布局title 标题date 文件建立日期设置文章摘要以上是文章摘要 以下是余下全文写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 变量 描述12345678910:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法1npm install hexo-deployer-git --save 3.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance 1npm install bcrypt RSS不显示安装RSS插件 1npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 添加站点地图站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站 安装插件打开hexo目录下的dos命令行，分别安装百度和google插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客目录的_config.yml中添加如下代码自动生成sitemap1234sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 编译你的博客","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiangshaobo.cn/tags/hexo/"},{"name":"hexo g","slug":"hexo-g","permalink":"https://jiangshaobo.cn/tags/hexo-g/"},{"name":"hexo d","slug":"hexo-d","permalink":"https://jiangshaobo.cn/tags/hexo-d/"},{"name":"hexo s","slug":"hexo-s","permalink":"https://jiangshaobo.cn/tags/hexo-s/"},{"name":"hexo p","slug":"hexo-p","permalink":"https://jiangshaobo.cn/tags/hexo-p/"},{"name":"hexo n","slug":"hexo-n","permalink":"https://jiangshaobo.cn/tags/hexo-n/"}]}]